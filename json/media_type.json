[{"mediatypeid": "1", "type": "0", "name": "Email", "smtp_server": "mail.example.com", "smtp_helo": "example.com", "smtp_email": "zabbix@example.com", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "0", "script": "", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": []}, {"mediatypeid": "3", "type": "2", "name": "SMS", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "/dev/ttyS0", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": []}, {"mediatypeid": "4", "type": "0", "name": "Email (HTML)", "smtp_server": "mail.example.com", "smtp_helo": "example.com", "smtp_email": "zabbix@example.com", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": []}, {"mediatypeid": "5", "type": "4", "name": "Mattermost", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "1", "attempt_interval": "10s", "content_type": "1", "script": "var SEVERITY_COLORS = [\r\n    '#97AAB3', '#7499FF', '#FFC859',\r\n    '#FFA059', '#E97659', '#E45959'\r\n];\r\n\r\nvar RESOLVE_COLOR = '#009900';\r\n\r\nvar SEND_MODE_HANDLERS = {\r\n    alarm: handlerAlarm,\r\n    event: handlerEvent\r\n};\r\n\r\nif (!String.prototype.format) {\r\n    String.prototype.format = function() {\r\n        var args = arguments;\r\n\r\n        return this.replace(/{(\\d+)}/g, function(match, number) {\r\n            return number in args\r\n                ? args[number]\r\n                : match\r\n            ;\r\n        });\r\n    };\r\n}\r\n\r\nfunction isEventProblem(params) {\r\n    return params.event_value == 1\r\n        && params.event_update_status == 0\r\n    ;\r\n}\r\n\r\nfunction isEventUpdate(params) {\r\n    return params.event_value == 1\r\n        && params.event_update_status == 1\r\n    ;\r\n}\r\n\r\nfunction isEventResolve(params) {\r\n    return params.event_value == 0;\r\n}\r\n\r\nfunction getPermalink(mattermost_url, team_name, postid) {\r\n    return '{0}/{1}/pl/{2}'.format(\r\n        mattermost_url.replace(/\\/+$/, ''),\r\n        team_name,\r\n        postid\r\n    );\r\n}\r\n\r\nfunction getChannel(send_to) {\r\n    switch (true) {\r\n        case /.+\\/#.+/.test(send_to):\r\n            return getChannelByName(send_to);\r\n\r\n        case /@.+/.test(send_to):\r\n            return getDirectChannel(send_to);\r\n\r\n        default:\r\n            return getChannelByID(send_to);\r\n    }\r\n}\r\n\r\nfunction getChannelByName(send_to) {\r\n    var team_chan = send_to\r\n        .trim()\r\n        .split('/#');\r\n\r\n    var resp = JSON.parse(req.get(\r\n        Mattermost.channel_byname.format(team_chan[0], team_chan[1]),\r\n        JSON.stringify(fields)\r\n    )\r\n    );\r\n\r\n    if (req.getStatus() != 200) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    return resp;\r\n}\r\n\r\nfunction getDirectChannel(send_to) {\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(arguments)\r\n    ));\r\n\r\n    var teamUser = send_to\r\n            .trim()\r\n            .split('/@'),\r\n        bot = getBotUser(),\r\n        user = getUserByName(teamUser[1]);\r\n\r\n    var resp = JSON.parse(req.post(\r\n        Mattermost.direct_channel,\r\n        JSON.stringify([bot.id, user.id])\r\n    )\r\n    );\r\n\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(resp)\r\n    ));\r\n\r\n    if (req.getStatus() != 201) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    resp.team_name = teamUser[0];\r\n\r\n    return resp;\r\n}\r\n\r\nfunction getChannelByID(channelID) {\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(arguments)\r\n    ));\r\n\r\n    var resp = JSON.parse(req.get(\r\n        Mattermost.get_channel.format(channelID),\r\n        JSON.stringify(fields)\r\n    )\r\n    );\r\n\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(resp)\r\n    ));\r\n\r\n    if (req.getStatus() != 200) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    return resp;\r\n}\r\n\r\nfunction getBotUser() {\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(arguments)\r\n    ));\r\n\r\n    var resp = JSON.parse(req.get(\r\n        Mattermost.bot_user,\r\n        JSON.stringify(fields)\r\n    )\r\n    );\r\n\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(resp)\r\n    ));\r\n\r\n    if (req.getStatus() != 200) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    return resp;\r\n}\r\n\r\nfunction getUserByName(userName) {\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(arguments)\r\n    ));\r\n\r\n    var resp = JSON.parse(req.get(\r\n        Mattermost.user_byname.format(userName),\r\n        JSON.stringify(fields)\r\n    )\r\n    );\r\n\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(resp)\r\n    ));\r\n\r\n    if (req.getStatus() != 200) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    return resp;\r\n}\r\n\r\nfunction getTeamByID(teamID) {\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Call {0}({1})'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(arguments)\r\n    ));\r\n\r\n    var resp = JSON.parse(req.get(\r\n        Mattermost.get_team.format(teamID),\r\n        JSON.stringify(fields)\r\n    )\r\n    );\r\n\r\n    Zabbix.log(5, '[ Mattermost Webhook ] Result {0}: {1}'.format(\r\n        arguments.callee.name,\r\n        JSON.stringify(resp)\r\n    ));\r\n\r\n    if (req.getStatus() != 200) {\r\n        throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n    }\r\n\r\n    return resp;\r\n}\r\n\r\nfunction createProblemURL(zabbix_url, triggerid, eventid, event_source) {\r\n    var problem_url = '';\r\n    if (event_source === '0') {\r\n        problem_url = '{0}/tr_events.php?triggerid={1}&eventid={2}'\r\n            .format(\r\n                zabbix_url,\r\n                triggerid,\r\n                eventid\r\n            );\r\n    }\r\n    else {\r\n        problem_url = zabbix_url;\r\n    }\r\n\r\n    return problem_url;\r\n}\r\n\r\nfunction getTagValue(event_tags, key) {\r\n    var pattern = new RegExp('(' + key + ':.+)');\r\n    var tagValue = event_tags\r\n        .split(',')\r\n        .filter(function (v) {\r\n            return v.match(pattern);\r\n        })\r\n        .map(function (v) {\r\n            return v.split(':')[1];\r\n        })[0]\r\n        || 0;\r\n\r\n    return tagValue;\r\n}\r\n\r\nfunction handlerAlarm(req, params) {\r\n    var channel = getChannel(params.send_to);\r\n    var fields = {\r\n        channel_id: channel.id,\r\n        props: {}\r\n    };\r\n\r\n    if (isEventProblem(params)) {\r\n        var team_name = channel.team_name\r\n            ? channel.team_name\r\n            : getTeamByID(channel.team_id).name;\r\n\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        var resp = JSON.parse(req.post(\r\n            Mattermost.post_message,\r\n            JSON.stringify(fields)\r\n        )\r\n        );\r\n\r\n        if (req.getStatus() != 201) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n\r\n        result.tags.__mattermost_post_id = resp.id;\r\n        result.tags.__mattermost_channel_id = channel.id;\r\n        result.tags.__mattermost_channel_name = channel.name;\r\n        result.tags.__mattermost_message_link = getPermalink(\r\n            params.mattermost_url,\r\n            team_name,\r\n            resp.id\r\n        );\r\n\r\n    }\r\n    else if (isEventUpdate(params)) {\r\n        fields.root_id = getTagValue(params.event_tags, 'mattermost_post_id');\r\n\r\n        if (params.event_source === '0') {}\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_update_date,\r\n                params.event_update_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\r\n                true\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(\r\n            Mattermost.post_message, JSON.stringify(fields)\r\n        )\r\n        );\r\n\r\n        if (req.getStatus() != 201) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n\r\n    }\r\n    else if (isEventResolve(params)) {\r\n        fields.channel_id = getTagValue(params.event_tags, 'mattermost_channel_id');\r\n        fields.id = getTagValue(params.event_tags, 'mattermost_post_id');\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                RESOLVE_COLOR,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        var post_id = getTagValue(params.event_tags, 'mattermost_post_id');\r\n\r\n        resp = JSON.parse(req.put(\r\n            Mattermost.chat_update.format(post_id),\r\n            JSON.stringify(fields)\r\n        )\r\n        );\r\n\r\n        if (req.getStatus() != 200) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n    }\r\n}\r\n\r\nfunction handlerEvent(req, params) {\r\n    var channel = getChannel(params.send_to);\r\n    var fields = {\r\n        channel_id: channel.id,\r\n        props: {}\r\n    };\r\n\r\n    if (isEventProblem(params)) {\r\n        var team_name = channel.team_name\r\n            ? channel.team_name\r\n            : getTeamByID(channel.team_id).name;\r\n\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        var resp = JSON.parse(req.post(Mattermost.post_message, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 201) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n\r\n        result.tags.__mattermost_channel_name = channel.name;\r\n        result.tags.__mattermost_message_link = getPermalink(\r\n            params.mattermost_url,\r\n            team_name,\r\n            resp.id\r\n        );\r\n\r\n    }\r\n    else if (isEventUpdate(params)) {\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_update_date,\r\n                params.event_update_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\r\n                false\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Mattermost.post_message, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 201) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n\r\n    }\r\n    else if (isEventResolve(params)) {\r\n        fields.props.attachments = [\r\n            createMessage(\r\n                RESOLVE_COLOR,\r\n                params.event_recovery_date,\r\n                params.event_recovery_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Mattermost.post_message, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 201) {\r\n            throw '[{0}] {1}'.format(resp.status_code, resp.message);\r\n        }\r\n    }\r\n}\r\n\r\nfunction createMessage(\r\n    event_severity_color,\r\n    event_date,\r\n    event_time,\r\n    problem_url,\r\n    isShort\r\n) {\r\n    var message = {\r\n        fallbac: params.alert_subject,\r\n        title: params.alert_subject,\r\n        color: event_severity_color,\r\n        title_link: problem_url,\r\n        footer: problem_url,\r\n\r\n        fields: [\r\n            {\r\n                title: 'Host',\r\n                value: '{0} [{1}]'.format(params.host_name, params.host_ip),\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Event time',\r\n                value: '{0} {1}'.format(event_date, event_time),\r\n                short: true\r\n            }\r\n        ],\r\n    };\r\n\r\n    \r\n    if (params.event_source === '0') {\r\n        message.fields.push(\r\n            {\r\n                title: 'Severity',\r\n                value: params.event_severity,\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Opdata',\r\n                value: params.event_opdata,\r\n                short: true\r\n            }\r\n        );\r\n    }\r\n\r\n    if (!isShort && params.event_source === '0') {\r\n        message.fields.push(\r\n            {\r\n                title: 'Event tags',\r\n                value: '`{0}`'.format(params.event_tags.replace(/__.+?:(.+?,|.+)/g, '') || 'None'),\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Trigger description',\r\n                value: params.trigger_description,\r\n                short: true\r\n            }\r\n        );\r\n    }\r\n\r\n    if (params.event_source !== '0' || params.event_update_status === '1') {\r\n        message.fields.push(\r\n            {\r\n                title: 'Details',\r\n                value: params.alert_message,\r\n                short: false\r\n            }\r\n        );\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nfunction validateParams(params) {\r\n    if (typeof params.bot_token !== 'string' || params.bot_token.trim() === '') {\r\n        throw 'Field \"bot_token\" cannot be empty';\r\n    }\r\n\r\n    if (isNaN(params.event_id)) {\r\n        throw 'Field \"event_id\" is not a number';\r\n    }\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    if (params.event_source !== '0') {\r\n        params.event_nseverity = '0';\r\n        params.event_severity = 'Not classified';\r\n        params.event_update_status = '0';\r\n        params.send_mode = 'event';\r\n    }\r\n\r\n    if (params.event_source === '1' || params.event_source === '2') {\r\n        params.event_value = '1';\r\n    }\r\n\r\n    if (params.event_source === '1') {\r\n        params.host_name = params.discovery_host_dns;\r\n        params.host_ip = params.discovery_host_ip;\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\r\n    }\r\n\r\n    if (typeof params.event_severity !== 'string' || params.event_severity.trim() === '') {\r\n        throw 'Field \"event_severity\" cannot be empty';\r\n    }\r\n\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_value !== '0' && params.event_value !== '1') {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (typeof params.host_ip !== 'string' || params.host_ip.trim() === '') {\r\n        throw 'Field \"host_ip\" cannot be empty';\r\n    }\r\n\r\n    if (typeof params.host_name !== 'string' || params.host_name.trim() === '') {\r\n        throw 'Field \"host_name\" cannot be empty';\r\n    }\r\n\r\n    if (typeof params.mattermost_url !== 'string' || params.mattermost_url.trim() === '') {\r\n        throw 'Field \"mattermost_url\" cannot be empty';\r\n    }\r\n\r\n    if (!/^(http|https):\\/\\/.+/.test(params.mattermost_url)) {\r\n        throw 'Field \"mattermost_url\" must contain a schema';\r\n    }\r\n\r\n    if (['alarm', 'event'].indexOf(params.send_mode) === -1) {\r\n        throw 'Incorrect \"send_mode\" parameter given: ' + params.send_mode + '\\nMust be \"alarm\" or \"event\".';\r\n    }\r\n\r\n    if (typeof params.send_to !== 'string' || params.send_to.trim() === '') {\r\n        throw 'Field \"send_to\" cannot be empty';\r\n    }\r\n\r\n    if (isNaN(params.trigger_id) && params.event_source === '0') {\r\n        throw 'field \"trigger_id\" is not a number';\r\n    }\r\n\r\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '') {\r\n        throw 'Field \"zabbix_url\" cannot be empty';\r\n    }\r\n\r\n    if (!/^(http|https):\\/\\/.+/.test(params.zabbix_url)) {\r\n        throw 'Field \"zabbix_url\" must contain a schema';\r\n    }\r\n\r\n}\r\n\r\ntry {\r\n    var params = JSON.parse(value);\r\n\r\n    validateParams(params);\r\n\r\n    var req = new HttpRequest(),\r\n        fields = {},\r\n        result = {tags: {}};\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    req.addHeader('Content-Type: application/json; charset=utf-8');\r\n    req.addHeader('Authorization: Bearer ' + params.bot_token);\r\n\r\n    params.mattermost_url = params.mattermost_url.replace(/\\/+$/, '');\r\n    params.zabbix_url = params.zabbix_url.replace(/\\/+$/, '');\r\n\r\n    var APIEndpoint = params.mattermost_url + '/api/v4/';\r\n\r\n    var Mattermost = {\r\n        post_message: APIEndpoint + 'posts',\r\n        get_channel: APIEndpoint + 'channels/{0}',\r\n        get_team: APIEndpoint + 'teams/{0}',\r\n        chat_update: APIEndpoint + 'posts/{0}',\r\n        direct_channel: APIEndpoint + 'channels/direct',\r\n        channel_byname: APIEndpoint + 'teams/name/{0}/channels/name/{1}',\r\n        user_byname: APIEndpoint + 'users/username/{0}',\r\n        bot_user: APIEndpoint + 'users/me'\r\n\r\n    };\r\n\r\n    params.send_mode = params.send_mode.toLowerCase();\r\n    params.send_mode = params.send_mode in SEND_MODE_HANDLERS\r\n        ? params.send_mode\r\n        : 'alarm';\r\n\r\n    SEND_MODE_HANDLERS[params.send_mode](req, params);\r\n\r\n    if (params.event_source === '0') {\r\n        return JSON.stringify(result);\r\n    }\r\n    else {\r\n        return 'OK';\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ Mattermost Webhook ] Mattermost notification failed: ' + error);\r\n    throw 'Mattermost notification failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__mattermost_message_link}", "event_menu_name": "Open in Mattermost: {EVENT.TAGS.__mattermost_channel_name}", "description": "", "parameters": [{"name": "zabbix_url", "value": "{$ZABBIX.URL}"}, {"name": "bot_token", "value": "<YOUR BOT TOKEN>"}, {"name": "mattermost_url", "value": "<YOUR MATTERMOST URL>"}, {"name": "send_mode", "value": "alarm"}, {"name": "send_to", "value": "{ALERT.SENDTO}"}, {"name": "event_tags", "value": "{EVENT.TAGS}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_date", "value": "{EVENT.DATE}"}, {"name": "event_time", "value": "{EVENT.TIME}"}, {"name": "event_severity", "value": "{EVENT.SEVERITY}"}, {"name": "event_opdata", "value": "{EVENT.OPDATA}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "host_name", "value": "{HOST.HOST}"}, {"name": "host_ip", "value": "{HOST.IP}"}, {"name": "event_update_date", "value": "{EVENT.UPDATE.DATE}"}, {"name": "event_update_time", "value": "{EVENT.UPDATE.TIME}"}, {"name": "event_recovery_date", "value": "{EVENT.RECOVERY.DATE}"}, {"name": "event_recovery_time", "value": "{EVENT.RECOVERY.TIME}"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "discovery_host_dns", "value": "{DISCOVERY.DEVICE.DNS}"}, {"name": "discovery_host_ip", "value": "{DISCOVERY.DEVICE.IPADDRESS}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}]}, {"mediatypeid": "6", "type": "4", "name": "Opsgenie", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Media = {\r\n    params: {},\r\n    name: '',\r\n    labels: [],\r\n    HTTPProxy: '',\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Media.params = params;\r\n        Media.params.api += Media.params.api.endsWith('/') ? '' : '/';\r\n        Media.params.web += Media.params.web.endsWith('/') ? '' : '/';\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        if (typeof HTTPProxy !== 'undefined' && HTTPProxy.trim() !== '') {\r\n            Media.HTTPProxy = HTTPProxy;\r\n        }\r\n    },\r\n\r\n    setTags: function(event_tags_json) {\r\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\r\n                && event_tags_json !== '{EVENT.TAGSJSON}') {\r\n\r\n            try {\r\n                var tags = JSON.parse(event_tags_json),\r\n                    label;\r\n\r\n                tags.forEach(function (tag) {\r\n                    if (typeof tag.tag === 'string') {\r\n                        label = (tag.tag + (typeof tag.value !== 'undefined'\r\n                                && tag.value !== '' ? (':' + tag.value) : '')).replace(/\\s/g, '_');\r\n                        Media.labels.push(label);\r\n                    }\r\n                });\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Failed to parse \"event_tags_json\" param');\r\n            }\r\n        }\r\n    },\r\n\r\n    request: function (method, query, data, allow_404) {\r\n        if (typeof(allow_404) === 'undefined') {\r\n            allow_404 = false;\r\n        }\r\n\r\n        ['api', 'token'].forEach(function (field) {\r\n            if (typeof Media.params !== 'object' || typeof Media.params[field] === 'undefined'\r\n                    || Media.params[field] === '') {\r\n                throw 'Required ' + Media.name + ' param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Media.params.api + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: ' + Media.params.token);\r\n        request.setProxy(Media.HTTPProxy);\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Failed to parse response.');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if ((request.getStatus() < 200 || request.getStatus() >= 300)\r\n                && (!allow_404 || request.getStatus() !== 404)) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null) {\r\n                if (typeof response.errors === 'object' && Object.keys(response.errors).length > 0) {\r\n                    message += ': ' + JSON.stringify(response.errors);\r\n                }\r\n                else if (typeof response.errorMessages === 'object' && Object.keys(response.errorMessages).length > 0) {\r\n                    message += ': ' + JSON.stringify(response.errorMessages);\r\n                }\r\n                else if (typeof response.message === 'string') {\r\n                    message += ': ' + response.message;\r\n                }\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getAlertId: function (requestId) {\r\n        do {\r\n            resp = Media.request('get', 'requests/' + requestId, undefined, true);\r\n        }\r\n        while (typeof resp.response !== 'object' || typeof resp.response.data === 'undefined'\r\n                || resp.response.data.success === false);\r\n\r\n        if (typeof resp.response !== 'object' || typeof resp.response.data === 'undefined') {\r\n            throw 'Cannot get ' + Media.name + ' issue ID. Check debug log for more information.';\r\n        }\r\n\r\n        return resp;\r\n    }\r\n};\r\n\r\ntry {\r\n    var result = {tags: {}},\r\n        params = JSON.parse(value),\r\n        media = {},\r\n        fields = {},\r\n        resp = {},\r\n        responders = [],\r\n        tags = [],\r\n        required_params = [\r\n            'alert_subject',\r\n            'alert_message',\r\n            'event_id',\r\n            'event_source',\r\n            'event_value',\r\n            'event_update_status',\r\n            'opsgenie_api',\r\n            'opsgenie_web',\r\n            'opsgenie_token'\r\n        ],\r\n        severities = [\r\n            'not_classified',\r\n            'information',\r\n            'warning',\r\n            'average',\r\n            'high',\r\n            'disaster',\r\n            'resolved',\r\n            'default'\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n            if (key.startsWith('opsgenie_')) {\r\n                media[key.substring(9)] = params[key];\r\n            }\r\n        });\r\n\r\n    // Possible values of event_source:\r\n    // 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check event_value for trigger-based and internal events.\r\n    // Possible values: 1 for problem, 0 for recovering\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check event_update_status only for trigger-based events.\r\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check event_id for a numeric value.\r\n    if (isNaN(parseInt(params.event_id)) || params.event_id < 1) {\r\n        throw 'Incorrect \"event_id\" parameter given: ' + params.event_id + '\\nMust be a positive number.';\r\n    }\r\n\r\n    if ((params.event_source === '1' || params.event_source === '2')  && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for Trigger and Internal actions.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity]];\r\n    params.zbxurl = params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/');\r\n\r\n    Media.name = 'Opsgenie';\r\n    Media.setParams(media);\r\n    Media.params.token = 'GenieKey ' + Media.params.token;\r\n    Media.setProxy(params.HTTPProxy);\r\n    Media.setTags(params.event_tags_json); // Set Media.labels\r\n\r\n    // Create an issue.\r\n    // Numeric value of the event that triggered an action (1 for problem, 0 for recovering).\r\n    // Numeric value of the problem update status. Possible values:\r\n    // 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\r\n    if ((params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0)\r\n            || (params.event_source == 3 && params.event_value == 1)\r\n            || params.event_source == 1 || params.event_source == 2) {\r\n        fields.message = params.alert_subject;\r\n        fields.alias = params.event_id;\r\n        fields.description = params.alert_message;\r\n        fields.priority = priority;\r\n        fields.source = 'Zabbix';\r\n\r\n        if (params.event_source === '0') {\r\n            fields.details = {\r\n                'Zabbix server': params.zbxurl,\r\n                Problem: params.zbxurl + 'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id\r\n            };\r\n        }\r\n        else {\r\n            fields.details = {'Zabbix server': params.zbxurl};\r\n        }\r\n\r\n        if (typeof params.opsgenie_teams === 'string') {\r\n            responders = params.opsgenie_teams.split(',');\r\n            fields.responders = responders.map(function(team) {\r\n                return {type: 'team', name: team.trim()};\r\n            });\r\n        }\r\n\r\n        fields.tags = Media.labels;\r\n        if (typeof params.opsgenie_tags === 'string') {\r\n            tags = params.opsgenie_tags.split(',');\r\n            tags.forEach(function(item) {\r\n                fields.tags.push(item.trim());\r\n            });\r\n        }\r\n\r\n        resp = Media.request('post', '', fields);\r\n        if (typeof resp.response !== 'object' || typeof resp.response.result === 'undefined') {\r\n            throw 'Cannot create ' + Media.name + ' issue. Check debug log for more information.';\r\n        }\r\n\r\n        if (resp.status === 202) {\r\n            resp = Media.getAlertId(resp.response.requestId);\r\n            if (params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0) {\r\n                result.tags.__zbx_ops_issuekey = resp.response.data.alertId;\r\n                result.tags.__zbx_ops_issuelink = Media.params.web + 'alert/detail/' + resp.response.data.alertId;\r\n            }\r\n        }\r\n        else {\r\n            throw Media.name + ' response code is unexpected. Check debug log for more information.';\r\n        }\r\n    }\r\n    // Update a created issue.\r\n    else {\r\n        fields.user = (params.event_value != 0) ? params.zbxuser : '';\r\n        fields.note = params.alert_message;\r\n\r\n        resp = Media.request('post', params.event_id + '/notes?identifierType=alias', fields);\r\n        if (typeof resp.response !== 'object' || typeof resp.response.result === 'undefined') {\r\n            throw 'Cannot update ' + Media.name + ' issue. Check debug log for more information.';\r\n        }\r\n\r\n        if (resp.status === 202) {\r\n            resp = Media.getAlertId(resp.response.requestId);\r\n        }\r\n        else {\r\n            throw Media.name + ' response code is unexpected. Check debug log for more information.';\r\n        }\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ ' + Media.name + ' Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_ops_issuelink}", "event_menu_name": "Opsgenie: {EVENT.TAGS.__zbx_ops_issuekey}", "description": "Please refer to https://docs.opsgenie.com/docs/alert-api and https://www.zabbix.com/documentation/6.0/manual/config/notifications/media/webhook#example_scripts.\r\n  \r\nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\r\nAdd dedicated user with media type \"Opsgenie\".\r\nChange the values of the variables opsgenie_api (https://api.opsgenie.com/v2/alerts or https://api.eu.opsgenie.com/v2/alerts),\r\nopsgenie_web (for example, https://myzabbix.app.opsgenie.com), opsgenie_token.", "parameters": [{"name": "zbxurl", "value": "{$ZABBIX.URL}"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags_json", "value": "{EVENT.TAGSJSON}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "opsgenie_api", "value": "<put your opsgenie api>"}, {"name": "opsgenie_tags", "value": ""}, {"name": "opsgenie_teams", "value": ""}, {"name": "opsgenie_token", "value": "<put your token>"}, {"name": "opsgenie_web", "value": "<put your opsgenie web>"}, {"name": "severity_average", "value": "P3"}, {"name": "severity_default", "value": "P5"}, {"name": "severity_disaster", "value": "P1"}, {"name": "severity_high", "value": "P2"}, {"name": "severity_information", "value": "P5"}, {"name": "severity_not_classified", "value": "P5"}, {"name": "severity_warning", "value": "P4"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zbxuser", "value": "{USER.FULLNAME}"}]}, {"mediatypeid": "7", "type": "4", "name": "PagerDuty", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "try {\r\n\r\n    var params = JSON.parse(value),\r\n        req = new HttpRequest(),\r\n        fields = {},\r\n        resp = '';\r\n\r\n    // Correspondence between the PagerDuty and Zabbix severity level\r\n    var severityMapping = [\r\n        'info',    // Not classified\r\n        'info',    // Information\r\n        'warning', // Warning\r\n        'warning', // Average\r\n        'error',   // High\r\n        'critical' // Disaster\r\n    ];\r\n\r\n    if (!severityMapping[params.severity]) {\r\n        params.severity = '0';\r\n    }\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    if (isNaN(parseInt(params.eventid)) || params.eventid < 1) {\r\n        throw 'incorrect value for variable \"eventid\". The value must be a positive number.';\r\n    }\r\n    if (params.eventname.length < 1) {\r\n        throw 'incorrect value for variable \"eventname\". The value must be a non-empty string.';\r\n    }\r\n    if (isNaN(parseInt(params.severity)) || (params.severity < 0 && params.severity > 5)) {\r\n        throw 'incorrect value for variable \"severity\". The value must be a number 0..5.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.eventvalue !== '0' && params.eventvalue !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"eventvalue\" parameter given: \"' + params.eventvalue + '\".\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source === '0') {\r\n        if (params.hostname.length < 1) {\r\n            throw 'incorrect value for variable \"hostname\". The value must be a non-empty string.';\r\n        }\r\n        if (isNaN(parseInt(params.triggerid)) || params.triggerid < 1) {\r\n            throw 'incorrect value for variable \"triggerid\". The value must be a positive number.';\r\n        }\r\n        if (params.eventack != 'Yes' && params.eventack != 'No') {\r\n            throw 'incorrect value for variable \"eventack\". The value must be Yes or No.';\r\n        }\r\n        if (isNaN(parseInt(params.eventupdate)) || (params.eventupdate < 0 || params.eventupdate > 1)) {\r\n            throw 'incorrect value for variable \"eventupdate\". The value must be 0 or 1.';\r\n        }\r\n    }\r\n\r\n\r\n\r\n    req.addHeader('Content-Type: application/json');\r\n\r\n    fields.routing_key = params.token;\r\n    fields.dedup_key = params.eventid;\r\n\r\n    if (((params.eventvalue == 1) && (params.eventupdate == 0)) || params.event_source !== '0') {\r\n        fields.event_action = 'trigger';\r\n        fields.payload = {\r\n            summary: params.eventname,\r\n            source: (params.event_source === '1') ? 'Discovery' : params.hostname + ' : ' + params.hostip,\r\n            severity: severityMapping[params.severity],\r\n        };\r\n        \r\n        if (params.event_source === '0') {\r\n            fields.payload.custom_details = {\r\n                'Event date': params.eventdate,\r\n                'Event time': params.eventtime,\r\n                'Trigger description': params.triggerdesc,\r\n                'Trigger opdata': params.triggeropdata,\r\n                'Event tags': params.eventtags,\r\n                'Event host': params.hostname,\r\n                'Event host ip': params.hostip\r\n            };\r\n            fields.links = [{\r\n                href: params.url + '/tr_events.php?triggerid=' + params.triggerid + '&eventid=' + params.eventid,\r\n                text: 'Event link'\r\n            }];\r\n        }\r\n        else {\r\n            fields.payload.custom_details = {\r\n                'Alert message': params.alert_message\r\n            };\r\n        }\r\n\r\n        fields.client = 'Zabbix';\r\n        fields.client_url = params.url;\r\n    }\r\n    else if ((params.eventvalue == 1) && (params.eventupdate == 1) && (params.eventack == 'Yes'))\r\n        fields.event_action = 'acknowledge';\r\n    else if (params.eventvalue == 0)\r\n        fields.event_action = 'resolve';\r\n    else\r\n        throw 'incorrect values. Update message without ack will not be sent.';\r\n\r\n    Zabbix.log(4, '[PagerDuty Webhook] Sending request:' + JSON.stringify(fields));\r\n    resp = req.post('https://events.pagerduty.com/v2/enqueue',\r\n        JSON.stringify(fields)\r\n    );\r\n    Zabbix.log(4, '[PagerDuty Webhook] Receiving response:' + resp);\r\n\r\n    try {\r\n        resp = JSON.parse(resp);\r\n    }\r\n    catch (error) {\r\n        throw 'incorrect response. PagerDuty returned a non-JSON object.';\r\n    }\r\n\r\n    if (req.getStatus() != 202) {\r\n        if (typeof resp === 'object' && typeof resp.errors === 'object' && typeof resp.errors[0] === 'string') {\r\n            throw resp.errors[0];\r\n        }\r\n        else {\r\n            throw 'Unknown error.';\r\n        }\r\n    }\r\n\r\n    if (resp.status != 'success') {\r\n        throw 'Unknown error.';\r\n    }\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[PagerDuty Webhook] Notification failed : ' + error);\r\n    throw 'PagerDuty notification failed : ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "Please refer to https://v2.developer.pagerduty.com/docs/send-an-event-events-api-v2 and https://www.zabbix.com/documentation/6.0/manual/config/notifications/media/webhook#example_scripts.\r\n  \r\nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\r\nAdd a dedicated user with the media type \"PagerDuty\" and place the integration key in the \"token\" parameter to integrate into the service.", "parameters": [{"name": "token", "value": "<put your key>"}, {"name": "eventid", "value": "{EVENT.ID}"}, {"name": "eventname", "value": "{ALERT.SUBJECT}"}, {"name": "hostname", "value": "{HOST.NAME}"}, {"name": "hostip", "value": "{HOST.IP}"}, {"name": "severity", "value": "{EVENT.NSEVERITY}"}, {"name": "triggerdesc", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "triggeropdata", "value": "{EVENT.OPDATA}"}, {"name": "eventtags", "value": "{EVENT.TAGS}"}, {"name": "triggerid", "value": "{TRIGGER.ID}"}, {"name": "eventdate", "value": "{EVENT.DATE}"}, {"name": "eventtime", "value": "{EVENT.TIME}"}, {"name": "eventack", "value": "{EVENT.ACK.STATUS}"}, {"name": "eventupdate", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "eventvalue", "value": "{EVENT.VALUE}"}, {"name": "url", "value": "{$ZABBIX.URL}"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}]}, {"mediatypeid": "8", "type": "4", "name": "Pushover", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "0", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "try {\r\n    var params = JSON.parse(value),\r\n        request = new HttpRequest(),\r\n        data,\r\n        response,\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: 'default', color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        request.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['priority_' + severities[params.event_nseverity].name] || params.priority_default;\r\n\r\n    if (isNaN(priority) || priority < -2 || priority > 2) {\r\n        throw '\"priority\" should be -2..2';\r\n    }\r\n\r\n    if (params.event_source === '0' && isNaN(params.triggerid)) {\r\n        throw 'field \"triggerid\" is not a number';\r\n    }\r\n\r\n    if (isNaN(params.eventid)) {\r\n        throw 'field \"eventid\" is not a number';\r\n    }\r\n\r\n    if (typeof params.message !== 'string' || params.message.trim() === '') {\r\n        throw 'field \"message\" cannot be empty';\r\n    }\r\n\r\n    data = {\r\n        token: params.token,\r\n        user: params.user,\r\n        title: params.title,\r\n        message: params.message,\r\n        url: (params.event_source === '0') \r\n            ? params.url + '/tr_events.php?triggerid=' + params.triggerid + '&eventid=' + params.eventid\r\n            : params.url,\r\n        url_title: params.url_title,\r\n        priority: priority\r\n    };\r\n\r\n    if (priority == 2) {\r\n        if (isNaN(params.retry) || params.retry < 30) {\r\n            throw 'field \"retry\" should be a number with value of at least 30 if \"priority\" is set to 2';\r\n        }\r\n\r\n        if (isNaN(params.expire) || params.expire > 10800) {\r\n            throw 'field \"expire\" should be a number with value of at most 10800 if \"priority\" is set to 2';\r\n        }\r\n\r\n        data.retry = params.retry;\r\n        data.expire = params.expire;\r\n    }\r\n\r\n    data = JSON.stringify(data);\r\n    Zabbix.log(4, '[ Pushover Webhook ] Sending request: ' + params.endpoint + '\\n' + data);\r\n\r\n    request.addHeader('Content-Type: application/json');\r\n    response = request.post(params.endpoint, data);\r\n\r\n    Zabbix.log(4, '[ Pushover Webhook ] Received response with status code ' + request.getStatus() + '\\n' + response);\r\n\r\n    if (response !== null) {\r\n        try {\r\n            response = JSON.parse(response);\r\n        }\r\n        catch (error) {\r\n            Zabbix.log(4, '[ Pushover Webhook ] Failed to parse response received from Pushover');\r\n            response = null;\r\n        }\r\n    }\r\n\r\n    if (request.getStatus() != 200 || response === null || typeof response !== 'object' || response.status !== 1) {\r\n        if (response !== null && typeof response === 'object' && typeof response.errors === 'object'\r\n                && typeof response.errors[0] === 'string') {\r\n            throw response.errors[0];\r\n        }\r\n        else {\r\n            throw 'Unknown error. Check debug log for more information.';\r\n        }\r\n    }\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ Pushover Webhook ] Pushover notification failed: ' + error);\r\n    throw 'Pushover notification failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "Please refer to setup guide here: https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/media/pushover\r\n\r\nSet token parameter with to your Pushover application key.\r\nWhen assigning Pushover media to the Zabbix user - add user key into send to field.", "parameters": [{"name": "token", "value": "<PUSHOVER TOKEN HERE>"}, {"name": "user", "value": "{ALERT.SENDTO}"}, {"name": "message", "value": "{ALERT.MESSAGE}"}, {"name": "title", "value": "{ALERT.SUBJECT}"}, {"name": "url", "value": "{$ZABBIX.URL}"}, {"name": "url_title", "value": "Zabbix"}, {"name": "eventid", "value": "{EVENT.ID}"}, {"name": "triggerid", "value": "{TRIGGER.ID}"}, {"name": "endpoint", "value": "https://api.pushover.net/1/messages.json"}, {"name": "retry", "value": "60"}, {"name": "expire", "value": "1200"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "priority_average", "value": "0"}, {"name": "priority_default", "value": "0"}, {"name": "priority_disaster", "value": "0"}, {"name": "priority_high", "value": "0"}, {"name": "priority_information", "value": "0"}, {"name": "priority_not_classified", "value": "0"}, {"name": "priority_warning", "value": "0"}]}, {"mediatypeid": "9", "type": "4", "name": "Slack", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var SEVERITY_COLORS = [\r\n    '#97AAB3', '#7499FF', '#FFC859',\r\n    '#FFA059', '#E97659', '#E45959'\r\n];\r\n\r\nvar RESOLVE_COLOR = '#009900';\r\n\r\nvar SLACK_MODE_HANDLERS = {\r\n    alarm: handlerAlarm,\r\n    event: handlerEvent\r\n};\r\n\r\n\r\nif (!String.prototype.format) {\r\n    String.prototype.format = function() {\r\n        var args = arguments;\r\n\r\n        return this.replace(/{(\\d+)}/g, function(match, number) {\r\n            return number in args\r\n                ? args[number]\r\n                : match\r\n            ;\r\n        });\r\n    };\r\n}\r\n\r\nfunction isEventProblem(params) {\r\n    return params.event_value == 1\r\n        && params.event_update_status == 0\r\n    ;\r\n}\r\n\r\nfunction isEventUpdate(params) {\r\n    return params.event_value == 1\r\n        && params.event_update_status == 1\r\n    ;\r\n}\r\n\r\nfunction isEventResolve(params) {\r\n    return params.event_value == 0;\r\n}\r\n\r\nfunction getPermalink(channelId, messageTimestamp) {\r\n    var req = new HttpRequest();\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    req.addHeader('Content-Type: application/x-www-form-urlencoded; charset=utf-8');\r\n    req.addHeader('Authorization: Bearer ' + params.bot_token);\r\n\r\n    var query = '{0}?channel={1}&message_ts={2}'.format(\r\n            Slack.getPermalink,\r\n            encodeURIComponent(channelId),\r\n            encodeURIComponent(messageTimestamp)),\r\n        resp = JSON.parse(req.get(query));\r\n\r\n    if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n        throw 'message was created, but getting message link was failed with reason \"' + resp.error + '\"';\r\n    }\r\n\r\n    return resp.permalink;\r\n}\r\n\r\nfunction createProblemURL(zabbix_url, triggerid, eventid, event_source) {\r\n    var problem_url = '';\r\n    if (event_source === '0') {\r\n        problem_url = '{0}/tr_events.php?triggerid={1}&eventid={2}'\r\n            .format(\r\n                zabbix_url,\r\n                triggerid,\r\n                eventid\r\n            );\r\n    }\r\n    else {\r\n        problem_url = zabbix_url;\r\n    }\r\n\r\n    return problem_url;\r\n}\r\n\r\nfunction handlerAlarm(params) {\r\n    var fields = {\r\n        channel: params.channel,\r\n        as_user: params.slack_as_user,\r\n    };\r\n\r\n    if (isEventProblem(params)) {\r\n        fields.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        var resp = JSON.parse(req.post(Slack.postMessage, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n\r\n        result.tags = {\r\n            ['__message_ts_' + params.channel]: resp.ts,\r\n            ['__channel_id_' + params.channel]: resp.channel,\r\n            ['__message_link_' + params.channel]: getPermalink(resp.channel, resp.ts),\r\n        };\r\n\r\n    }\r\n    else if (isEventUpdate(params)) {\r\n        try {\r\n            var channel_event_tags = JSON.parse(params.event_tags);\r\n        } catch (error) {\r\n            throw 'Cannot process event tags: ' + error;\r\n        }\r\n\r\n        if (Array.isArray(channel_event_tags)) {\r\n            for (i in channel_event_tags) {\r\n                if (channel_event_tags[i].tag.includes('__message_ts_' + params.channel)) {\r\n                    fields.thread_ts = channel_event_tags[i].value;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        fields.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_update_date,\r\n                params.event_update_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\r\n                true\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Slack.postMessage, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n\r\n    }\r\n    else if (isEventResolve(params)) {\r\n\r\n        fields.text = '';\r\n\r\n        try {\r\n            var channel_event_tags = JSON.parse(params.event_tags);\r\n        } catch (error) {\r\n            throw 'Cannot process event tags: ' + error;\r\n        }\r\n\r\n        if (Array.isArray(channel_event_tags)) {\r\n            for (i in channel_event_tags) {\r\n                if (channel_event_tags[i].tag.includes('__channel_id_' + params.channel)) {\r\n                    fields.channel = channel_event_tags[i].value;\r\n                    continue;\r\n                }\r\n                if (channel_event_tags[i].tag.includes('__message_ts_' + params.channel)) {\r\n                    fields.ts = channel_event_tags[i].value;\r\n                }\r\n            }\r\n        }\r\n\r\n        fields.attachments = [\r\n            createMessage(\r\n                RESOLVE_COLOR,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Slack.chatUpdate, JSON.stringify(fields)));\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n    }\r\n}\r\n\r\nfunction handlerEvent(params) {\r\n    var fields = {\r\n        channel: params.channel,\r\n        as_user: params.slack_as_user\r\n    };\r\n\r\n    if (isEventProblem(params)) {\r\n        fields.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_date,\r\n                params.event_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        var resp = JSON.parse(req.post(Slack.postMessage, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n\r\n        result.tags = {\r\n            ['__message_link_' + params.channel]: getPermalink(resp.channel, resp.ts)\r\n        }\r\n\r\n    }\r\n    else if (isEventUpdate(params)) {\r\n        fields.attachments = [\r\n            createMessage(\r\n                SEVERITY_COLORS[params.event_nseverity] || 0,\r\n                params.event_update_date,\r\n                params.event_update_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source),\r\n                false\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Slack.postMessage, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n\r\n    }\r\n    else if (isEventResolve(params)) {\r\n        fields.attachments = [\r\n            createMessage(\r\n                RESOLVE_COLOR,\r\n                params.event_recovery_date,\r\n                params.event_recovery_time,\r\n                createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source)\r\n            )\r\n        ];\r\n\r\n        resp = JSON.parse(req.post(Slack.postMessage, JSON.stringify(fields)));\r\n\r\n        if (req.getStatus() != 200 || !resp.ok || resp.ok === 'false') {\r\n            throw resp.error;\r\n        }\r\n    }\r\n}\r\n\r\nfunction createMessage(\r\n    event_severity_color,\r\n    event_date,\r\n    event_time,\r\n    problem_url,\r\n    isShort,\r\n    messageText\r\n) {\r\n    var message = {\r\n        fallback: params.alert_subject,\r\n        title: params.alert_subject,\r\n        color: event_severity_color,\r\n        title_link: problem_url,\r\n        pretext: messageText || '',\r\n\r\n        fields: [\r\n            {\r\n                title: 'Host',\r\n                value: '{0} [{1}]'.format(params.host_name, params.host_conn),\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Event time',\r\n                value: '{0} {1}'.format(event_date, event_time),\r\n                short: true\r\n            }\r\n        ],\r\n    };\r\n\r\n    if (params.event_source === '0') {\r\n        message.fields.push(\r\n            {\r\n                title: 'Severity',\r\n                value: params.event_severity,\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Opdata',\r\n                value: params.event_opdata,\r\n                short: true\r\n            }\r\n        );\r\n    }\r\n\r\n    if (!isShort  && params.event_source === '0') {\r\n        message['actions'] = [\r\n            {\r\n                type: 'button',\r\n                text: 'Open in Zabbix',\r\n                url: problem_url\r\n            }\r\n        ];\r\n\r\n        message.fields.push(\r\n            {\r\n                title: 'Event tags',\r\n                value: JSON.parse(params.event_tags).filter(function (e) { return !e.tag.includes('__') }).map(function (e) { return e.tag + ': ' + e.value }).join('\\n') || 'None',\r\n                short: true\r\n            },\r\n            {\r\n                title: 'Trigger description',\r\n                value: params.trigger_description,\r\n                short: true\r\n            }\r\n        );\r\n    }\r\n\r\n    if (params.event_source !== '0' || params.event_update_status === '1') {\r\n        message.fields.push(\r\n            {\r\n                title: 'Details',\r\n                value: params.alert_message,\r\n                short: false\r\n            }\r\n        );\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nfunction validateParams(params) {\r\n    if (typeof params.bot_token !== 'string' || params.bot_token.trim() === '') {\r\n        throw 'Field \"bot_token\" cannot be empty';\r\n    }\r\n\r\n    if (typeof params.channel !== 'string' || params.channel.trim() === '') {\r\n        throw 'Field \"channel\" cannot be empty';\r\n    }\r\n\r\n    if (isNaN(params.event_id)) {\r\n        throw 'Field \"event_id\" is not a number';\r\n    }\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    if (params.event_source !== '0') {\r\n        params.event_nseverity = '0';\r\n        params.event_severity = 'Not classified';\r\n        params.event_update_status = '0';\r\n        params.slack_mode = 'event';\r\n    }\r\n\r\n    if (params.event_source === '1' || params.event_source === '2') {\r\n        params.event_value = '1';\r\n    }\r\n\r\n    if (params.event_source === '1') {\r\n        params.host_name = params.discovery_host_dns;\r\n        params.host_ip = params.discovery_host_ip;\r\n    }\r\n\r\n    if (!~[0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity))) {\r\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\r\n    }\r\n\r\n    if (typeof params.event_severity !== 'string' || params.event_severity.trim() === '') {\r\n        throw 'Field \"event_severity\" cannot be empty';\r\n    }\r\n\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_value !== '0' && params.event_value !== '1') {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (typeof params.host_conn !== 'string' || params.host_conn.trim() === '') {\r\n        throw 'Field \"host_conn\" cannot be empty';\r\n    }\r\n\r\n    if (typeof params.host_name !== 'string' || params.host_name.trim() === '') {\r\n        throw 'Field \"host_name\" cannot be empty';\r\n    }\r\n\r\n    if (!~['true', 'false'].indexOf(params.slack_as_user.toLowerCase())) {\r\n        throw 'Incorrect \"slack_as_user\" parameter given: ' + params.slack_as_user + '\\nMust be \"true\" or \"false\".';\r\n    }\r\n\r\n    if (!~['alarm', 'event'].indexOf(params.slack_mode)) {\r\n        throw 'Incorrect \"slack_mode\" parameter given: ' + params.slack_mode + '\\nMust be \"alarm\" or \"event\".';\r\n    }\r\n\r\n    if (isNaN(params.trigger_id) && params.event_source === '0') {\r\n        throw 'field \"trigger_id\" is not a number';\r\n    }\r\n\r\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '') {\r\n        throw 'Field \"zabbix_url\" cannot be empty';\r\n    }\r\n\r\n    if (!/^(http|https):\\/\\/.+/.test(params.zabbix_url)) {\r\n        throw 'Field \"zabbix_url\" must contain a schema';\r\n    }\r\n}\r\n\r\ntry {\r\n    var params = JSON.parse(value);\r\n\r\n    validateParams(params);\r\n\r\n    var req = new HttpRequest(),\r\n        result = {tags: {}};\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    req.addHeader('Content-Type: application/json; charset=utf-8');\r\n    req.addHeader('Authorization: Bearer ' + params.bot_token);\r\n\r\n    var slack_endpoint = 'https://slack.com/api/';\r\n\r\n    var Slack = {\r\n        postMessage: slack_endpoint + 'chat.postMessage',\r\n        getPermalink: slack_endpoint + 'chat.getPermalink',\r\n        chatUpdate: slack_endpoint + 'chat.update'\r\n    };\r\n\r\n    params.slack_mode = params.slack_mode.toLowerCase();\r\n    params.slack_mode = params.slack_mode in SLACK_MODE_HANDLERS\r\n        ? params.slack_mode\r\n        : 'alarm';\r\n\r\n    SLACK_MODE_HANDLERS[params.slack_mode](params);\r\n\r\n    if (params.event_source === '0') {\r\n        return JSON.stringify(result);\r\n    }\r\n    else {\r\n        return 'OK';\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ Slack Webhook ] Slack notification failed : ' + error);\r\n    throw 'Slack notification failed : ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "zabbix_url", "value": "{$ZABBIX.URL}"}, {"name": "bot_token", "value": "<PLACE YOUR KEY HERE>"}, {"name": "channel", "value": "{ALERT.SENDTO}"}, {"name": "slack_mode", "value": "alarm"}, {"name": "slack_as_user", "value": "true"}, {"name": "event_tags", "value": "{EVENT.TAGSJSON}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_date", "value": "{EVENT.DATE}"}, {"name": "event_time", "value": "{EVENT.TIME}"}, {"name": "event_severity", "value": "{EVENT.SEVERITY}"}, {"name": "event_opdata", "value": "{EVENT.OPDATA}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "host_name", "value": "{HOST.NAME}"}, {"name": "event_update_date", "value": "{EVENT.UPDATE.DATE}"}, {"name": "event_update_time", "value": "{EVENT.UPDATE.TIME}"}, {"name": "event_recovery_date", "value": "{EVENT.RECOVERY.DATE}"}, {"name": "event_recovery_time", "value": "{EVENT.RECOVERY.TIME}"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "discovery_host_dns", "value": "{DISCOVERY.DEVICE.DNS}"}, {"name": "discovery_host_ip", "value": "{DISCOVERY.DEVICE.IPADDRESS}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "host_conn", "value": "{HOST.CONN}"}]}, {"mediatypeid": "10", "type": "4", "name": "Discord", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var SEVERITY_COLORS = [\r\n    '#97AAB3', // Not classified.\r\n    '#7499FF', // Information.\r\n    '#FFC859', // Warning.\r\n    '#FFA059', // Average.\r\n    '#E97659', // High.\r\n    '#E45959', // Disaster.\r\n    '#009900'  // Resolved.\r\n];\r\n\r\nfunction stringTruncate(str, len) {\r\n    return str.length > len ? str.substring(0, len - 3) + '...' : str;\r\n}\r\n\r\ntry {\r\n    Zabbix.log(4, '[ Discord Webhook ] Executed with params: ' + value);\r\n\r\n    var params = JSON.parse(value);\r\n\r\n    if (!params.discord_endpoint) {\r\n        throw 'Cannot get discord_endpoint';\r\n    }\r\n    else {\r\n        params.discord_endpoint = params.discord_endpoint.replace('/api/', '/api/v7/') + '?wait=True';\r\n    }\r\n\r\n    params.zabbix_url = (params.zabbix_url.endsWith('/'))\r\n        ? params.zabbix_url.slice(0, -1) : params.zabbix_url;\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    // Set params to true for non trigger-based events.\r\n    if (params.event_source !== '0') {\r\n        params.use_default_message = 'true';\r\n        params.event_nseverity = '0';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: \"' + params.event_value + '\".\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: \"' + params.event_update_status + '\".\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_value == 0) {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    if (!SEVERITY_COLORS[params.event_nseverity]) {\r\n        throw 'Incorrect \"event_nseverity\" parameter given: ' + params.event_nseverity + '\\nMust be 0-5.';\r\n    }\r\n\r\n    var color = parseInt(SEVERITY_COLORS[params.event_nseverity].replace('#', ''), 16),\r\n        fields = [],\r\n        body = {\r\n            embeds: [\r\n                {\r\n                    color: color || 0,\r\n                    url: (params.event_source === '0')\r\n                        ? params.zabbix_url + '/tr_events.php?triggerid=' + params.trigger_id +\r\n                            '&eventid=' + params.event_id\r\n                        : params.zabbix_url\r\n                }\r\n            ]\r\n        };\r\n\r\n    // Default message from {ALERT.MESSAGE}.\r\n    if (params.use_default_message.toLowerCase() == 'true') {\r\n        body.embeds[0].title = stringTruncate(params.alert_subject, 256);\r\n        body.embeds[0].description = stringTruncate(params.alert_message, 2048);\r\n    }\r\n    else {\r\n        fields.push(\r\n            {\r\n                name: 'Host',\r\n                value: params.host_name + ' [' + params.host_ip + ']'\r\n            }\r\n        );\r\n\r\n        // Resolved message.\r\n        if (params.event_value == 0 && params.event_update_status == 0) {\r\n            body.embeds[0].title = stringTruncate('OK: ' + params.event_name, 256);\r\n            fields.push(\r\n                {\r\n                    name: 'Recovery time',\r\n                    value: params.event_recovery_time + ' ' + params.event_recovery_date,\r\n                    inline: 'True'\r\n                }\r\n            );\r\n        }\r\n\r\n        // Problem message.\r\n        else if (params.event_value == 1 && params.event_update_status == 0) {\r\n            body.embeds[0].title = stringTruncate('PROBLEM: ' + params.event_name, 256);\r\n            fields.push(\r\n                {\r\n                    name: 'Event time',\r\n                    value: params.event_time + ' ' + params.event_date,\r\n                    inline: 'True'\r\n                }\r\n            );\r\n        }\r\n\r\n        // Update message.\r\n        else if (params.event_update_status == 1) {\r\n            body.embeds[0].title = stringTruncate('UPDATE: ' + params.event_name, 256);\r\n            body.embeds[0].description = params.event_update_user + ' ' + params.event_update_action + '.';\r\n\r\n            if (params.event_update_message) {\r\n                body.embeds[0].description += ' Comment:\\n>>> ' + params.event_update_message;\r\n            }\r\n\r\n            body.embeds[0].description = stringTruncate(body.embeds[0].description, 2048);\r\n\r\n            fields.push(\r\n                {\r\n                    name: 'Event update time',\r\n                    value: params.event_update_time + ' ' + params.event_update_date,\r\n                    inline: 'True'\r\n                }\r\n            );\r\n        }\r\n\r\n        fields.push(\r\n            {\r\n                name: 'Severity',\r\n                value: params.event_severity,\r\n                inline: 'True'\r\n            }\r\n        );\r\n\r\n        if (params.event_opdata) {\r\n            fields.push(\r\n                {\r\n                    name: 'Operational data',\r\n                    value: stringTruncate(params.event_opdata, 1024),\r\n                    inline: 'True'\r\n                }\r\n            );\r\n        }\r\n\r\n        if (params.event_value == 1 && params.event_update_status == 0 && params.trigger_description) {\r\n            fields.push(\r\n                {\r\n                    name: 'Trigger description',\r\n                    value: stringTruncate(params.trigger_description, 1024)\r\n                }\r\n            );\r\n        }\r\n\r\n        body.embeds[0].footer = {\r\n            text: 'Event ID: ' + params.event_id\r\n        };\r\n\r\n        if (params.event_tags) {\r\n            body.embeds[0].footer.text += '\\nEvent tags: ' + params.event_tags;\r\n        }\r\n        body.embeds[0].footer.text = stringTruncate(body.embeds[0].footer.text, 2048);\r\n    }\r\n\r\n    if (fields.length > 0) {\r\n        body.embeds[0].fields = fields;\r\n    }\r\n\r\n    var req = new HttpRequest();\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    req.addHeader('Content-Type: application/json');\r\n\r\n    var resp = req.post(params.discord_endpoint, JSON.stringify(body)),\r\n        data = JSON.parse(resp);\r\n\r\n    Zabbix.log(4, '[ Discord Webhook ] JSON: ' + JSON.stringify(body));\r\n    Zabbix.log(4, '[ Discord Webhook ] Response: ' + resp);\r\n\r\n    if (data.id) {\r\n        return resp;\r\n    }\r\n    else {\r\n        var message = ((typeof data.message === 'string') ? data.message : 'Unknown error');\r\n\r\n        Zabbix.log(3, '[ Discord Webhook ] FAILED with response: ' + resp);\r\n        throw message + '. For more details check zabbix server log.';\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Discord Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "zabbix_url", "value": "{$ZABBIX.URL}"}, {"name": "discord_endpoint", "value": "{ALERT.SENDTO}"}, {"name": "use_default_message", "value": "false"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_name", "value": "{EVENT.NAME}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_severity", "value": "{EVENT.SEVERITY}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_opdata", "value": "{EVENT.OPDATA}"}, {"name": "event_tags", "value": "{EVENT.TAGS}"}, {"name": "event_time", "value": "{EVENT.TIME}"}, {"name": "event_date", "value": "{EVENT.DATE}"}, {"name": "event_recovery_date", "value": "{EVENT.RECOVERY.DATE}"}, {"name": "event_recovery_time", "value": "{EVENT.RECOVERY.TIME}"}, {"name": "event_update_date", "value": "{EVENT.UPDATE.DATE}"}, {"name": "event_update_time", "value": "{EVENT.UPDATE.TIME}"}, {"name": "event_update_action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_update_user", "value": "{USER.FULLNAME}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "host_ip", "value": "{HOST.IP}"}, {"name": "host_name", "value": "{HOST.NAME}"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}]}, {"mediatypeid": "11", "type": "4", "name": "SIGNL4", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "// SIGNL4 Webhook\r\ntry {\r\n    var response,\r\n        payload,\r\n        params = JSON.parse(value),\r\n        endpoint = 'https://connect.signl4.com/webhook/',\r\n        request = new HttpRequest();\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        request.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    if (typeof params.teamsecret === 'string' && params.teamsecret.trim() !== '') {\r\n        endpoint += params.teamsecret;\r\n        delete params.teamsecret;\r\n    }\r\n    else {\r\n        throw 'The team secret of your SIGNL4 team cannot be empty.';\r\n    }\r\n\r\n    if (typeof params.Severity === 'string' && params.Severity === '{EVENT.SEVERITY}') {\r\n        params.Severity = 'Not classified';\r\n    }\r\n\r\nif (typeof params.User === 'string' && params.User === '{USER.FULLNAME}') {\r\n        params.User = '';\r\n    }\r\n\r\nif (typeof params.Event_Update_Action === 'string' && params.Event_Update_Action === '{EVENT.UPDATE.ACTION}') {\r\n        params.Event_Update_Action = '';\r\n    }\r\n\r\n// Assemble X-S4-ExternalID for two-way integration\r\n// Format: \"ZabbixEventID: 222 ZabbixURL: https://your-zabbix-server/zabbix/\"\r\nparams['X-S4-ExternalID'] = 'ZabbixEventID: ' + params.Event_ID;\r\nif (typeof params.Zabbix_URL === 'string' && params.Zabbix_URL.indexOf('http') == 0) {\r\n// Make sure the URL ends with '/'\r\nif (params.Zabbix_URL.charAt(params.Zabbix_URL.length - 1) != '/') {\r\nparams.Zabbix_URL = params.Zabbix_URL + '/';\r\n}\r\n\r\nparams['X-S4-ExternalID'] = params['X-S4-ExternalID'] + ' ZabbixURL: ' +  params.Zabbix_URL;\r\n\r\n// Add Link parameter\r\nparams['Link'] = params.Zabbix_URL + \"tr_events.php?triggerid=\"+params.Trigger_ID + \"&eventid=\" + params.Event_ID;\r\n}\r\n\r\n// Check if this is a new problem or a recovery\r\nif (params.Trigger_Status == 'OK') {\r\nparams['X-S4-Status'] = 'resolved';\r\n}\r\nelse {\r\nparams['X-S4-Status'] = 'new';\r\n}\r\n\r\n    payload = JSON.stringify(params);\r\n    Zabbix.log(4, '[ SIGNL4 Webhook ] Sending request: ' + payload);\r\n\r\n    request.addHeader('Content-Type: application/json');\r\n    response = request.post(endpoint, 'payload=' + payload);\r\n\r\n    Zabbix.log(4, '[ SIGNL4 Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response\r\n    );\r\n\r\n    if (request.getStatus() !== 201) {\r\n        throw 'Request failed with status code ' + request.getStatus() +\r\n                '. Check debug log for more information.';\r\n    }\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ SIGNL4 Webhook ] ERROR: ' + error);\r\n\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "SIGNL4 is a mobile alert notification app for powerful alerting, alert management and mobile assignment of work items. It offers alerting via app push, SMS and voice calls including escalations, tracking, and duty scheduling.\r\n\r\nGet the app at https://www.signl4.com.\r\n\r\nFind out more including an integration video here: https://www.signl4.com/blog/portfolio_item/zabbix-mobile-alert-notification-duty-schedule-escalation/", "parameters": [{"name": "teamsecret", "value": "{ALERT.SENDTO}"}, {"name": "Subject", "value": "{ALERT.SUBJECT}"}, {"name": "Message", "value": "{ALERT.MESSAGE}"}, {"name": "Severity", "value": "{EVENT.SEVERITY}"}, {"name": "Hostname", "value": "{HOST.NAME}"}, {"name": "Event_Ack_Status", "value": "{EVENT.ACK.STATUS}"}, {"name": "Event_Date_Time", "value": "{EVENT.DATE} {EVENT.TIME}"}, {"name": "Event_ID", "value": "{EVENT.ID}"}, {"name": "Event_Update_Action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "Event_Update_Status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "Host_IP", "value": "{HOST.IP}"}, {"name": "Trigger_ID", "value": "{TRIGGER.ID}"}, {"name": "Trigger_Status", "value": "{TRIGGER.STATUS}"}, {"name": "User", "value": "{USER.FULLNAME}"}, {"name": "Zabbix_URL", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "12", "type": "4", "name": "Jira", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Jira = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Jira.params = params;\r\n        if (typeof Jira.params.url === 'string') {\r\n            if (!Jira.params.url.endsWith('/')) {\r\n                Jira.params.url += '/';\r\n            }\r\n\r\n            Jira.params.url += 'rest/api/latest/';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Jira.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setTags: function(event_tags_json) {\r\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\r\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\r\n            try {\r\n                var tags = JSON.parse(event_tags_json),\r\n                    label;\r\n\r\n                Jira.labels = [];\r\n\r\n                tags.forEach(function (tag) {\r\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined'\r\n                        && !tag.tag.startsWith('__zbx')) {\r\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\r\n                        if (label.length < 256) {\r\n                            Jira.labels.push(label);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (error) {\r\n                // Code is not missing here.\r\n            }\r\n        }\r\n    },\r\n\r\n    escapeMarkup: function (str) {\r\n        var length = str.length,\r\n            result = '',\r\n            markup = ['{', '|', '}', '~', '_', '\\\\', '[', ']', '^', '<', '>', '?', '!', '#', '+', '*', '&'];\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            var char = str[i];\r\n\r\n            result += (markup.indexOf(char) !== -1) ? ('&#' + str[i].charCodeAt() + ';') : char;\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            var schema = Jira.getSchema(),\r\n                path = ['projects', 0, 'issuetypes', 0, 'fields'],\r\n                field;\r\n\r\n            while ((field = path.shift()) !== undefined) {\r\n                schema = schema[field];\r\n                if (typeof schema === 'undefined') {\r\n                    schema = null;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (schema) {\r\n                Object.keys(fields)\r\n                    .forEach(function(field) {\r\n                        if (typeof schema[field] === 'object' && typeof schema[field].schema === 'object') {\r\n                            switch (schema[field].schema.type) {\r\n                                case 'number':\r\n                                    data.fields[field] = parseInt(fields[field]);\r\n                                    break;\r\n\r\n                                case 'datetime':\r\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\r\n                                        data.fields[field] = fields[field].replace(/\\./g, '-');\r\n                                    }\r\n                                    break;\r\n\r\n                                case 'option':\r\n                                    data.fields[field] = {value: fields[field]};\r\n                                    break;\r\n\r\n                                case 'array':\r\n                                    if (schema[field].schema.items === 'option') {\r\n                                        data.fields[field] = [{value: fields[field]}];\r\n                                    }\r\n                                    else {\r\n                                        data.fields[field] = [fields[field]];\r\n                                    }\r\n                                    break;\r\n\r\n                                default:\r\n                                    data.fields[field] = fields[field];\r\n                            }\r\n                        }\r\n                    });\r\n            }\r\n            else {\r\n                Zabbix.log(4, '[ Jira Webhook ] Failed to retrieve field schema.');\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'user', 'password', 'project_key', 'issue_type'].forEach(function (field) {\r\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\r\n                || Jira.params[field] === '' ) {\r\n                throw 'Required Jira param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Jira.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\r\n\r\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\r\n            request.setProxy(Jira.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Jira Webhook ] Sending request: ' + url + ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ Jira Webhook ] Received response with status code ' + request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Jira Webhook ] Failed to parse response received from Jira');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.errors !== 'undefined'\r\n                && Object.keys(response.errors).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errors);\r\n            }\r\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\r\n                && Object.keys(response.errorMessages).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errorMessages);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getSchema: function() {\r\n        var result = Jira.request('get', 'issue/createmeta?expand=projects.issuetypes.fields&projectKeys=' +\r\n            encodeURIComponent(Jira.params.project_key) + '&issuetypeNames=' +\r\n            encodeURIComponent(Jira.params.issue_type));\r\n\r\n        return result.response;\r\n    },\r\n\r\n    createIssue: function(summary, description, fields) {\r\n        var data = {\r\n            fields: {\r\n                project: {\r\n                    key: Jira.params.project_key\r\n                },\r\n                issuetype: {\r\n                    name: Jira.params.issue_type\r\n                },\r\n                summary: summary,\r\n                description: description\r\n            }\r\n        };\r\n\r\n        if (Jira.labels && Jira.labels.length > 0) {\r\n            data.fields.labels = Jira.labels;\r\n        }\r\n        var result = Jira.request('post', 'issue', Jira.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.key === 'undefined') {\r\n            throw 'Cannot create Jira issue. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.key;\r\n    },\r\n\r\n    updateIssue: function(summary, fields, update) {\r\n        var data = {fields: {}};\r\n\r\n        if (summary) {\r\n            data.fields.summary = summary;\r\n        }\r\n\r\n        Jira.request('put', 'issue/' + encodeURIComponent(Jira.params.issue_key), Jira.addCustomFields(data, fields));\r\n        Jira.commentIssue(update);\r\n    },\r\n\r\n    commentIssue: function(update) {\r\n        var data = {};\r\n\r\n        if (typeof update === 'string') {\r\n            data.body = update;\r\n            Jira.request('post', 'issue/' + encodeURIComponent(Jira.params.issue_key) + '/comment', data);\r\n        }\r\n        else if (update.status === '1') {\r\n            data.body = update.user + ' ' + update.action + '.';\r\n\r\n            if (update.message) {\r\n                data.body += '\\nMessage: {quote}' + Jira.escapeMarkup(update.message) + '{quote}';\r\n            }\r\n\r\n            Jira.request('post', 'issue/' + encodeURIComponent(Jira.params.issue_key) + '/comment', data);\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        jira = {},\r\n        update = {},\r\n        result = {tags: {}},\r\n        required_params = ['alert_subject', 'summary', 'event_recovery_value', 'event_source', 'event_value'];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('jira_')) {\r\n                jira[key.substring(5)] = params[key];\r\n            }\r\n            else if (key.startsWith('customfield_')) {\r\n                fields[key] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    Jira.setParams(jira);\r\n    Jira.setProxy(params.HTTPProxy);\r\n    Jira.setTags(params.event_tags_json);\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        Jira.createIssue(params.alert_subject, params.alert_message);\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && update.status === '0' && !jira.issue_key.startsWith(jira.project_key)) {\r\n        var key = Jira.createIssue(params.alert_subject,\r\n            (Object.keys(fields).length ? params.trigger_description : params.alert_message), fields);\r\n\r\n\r\n        result.tags.__zbx_jira_issuekey = key;\r\n        result.tags.__zbx_jira_issuelink = params.jira_url +\r\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        if (!jira.issue_key.startsWith(jira.project_key)) {\r\n            throw 'Incorrect Issue key given: ' + jira.issue_key;\r\n        }\r\n        Jira.updateIssue(params.alert_subject, fields,\r\n            ((params.event_value === '0' && !Object.keys(fields).length)\r\n                ? params.alert_message : update));\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Jira Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_jira_issuelink}", "event_menu_name": "Jira: {EVENT.TAGS.__zbx_jira_issuekey}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags_json", "value": "{EVENT.TAGSJSON}"}, {"name": "event_update_action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_update_user", "value": "{USER.FULLNAME}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "jira_issue_key", "value": "{EVENT.TAGS.__zbx_jira_issuekey}"}, {"name": "jira_issue_type", "value": "<PLACE ISSUETYPE NAME>"}, {"name": "jira_password", "value": "<PLACE PASSWORD OR TOKEN>"}, {"name": "jira_project_key", "value": "<PLACE PROJECT KEY>"}, {"name": "jira_url", "value": "<PLACE YOUR JIRA URL>"}, {"name": "jira_user", "value": "<PLACE LOGIN>"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}]}, {"mediatypeid": "13", "type": "4", "name": "Jira with CustomFields", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Jira = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Jira.params = params;\r\n        if (typeof Jira.params.url === 'string') {\r\n            if (!Jira.params.url.endsWith('/')) {\r\n                Jira.params.url += '/';\r\n            }\r\n\r\n            Jira.params.url += 'rest/api/latest/';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Jira.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setTags: function(event_tags_json) {\r\n        if (typeof event_tags_json !== 'undefined' && event_tags_json !== ''\r\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\r\n            try {\r\n                var tags = JSON.parse(event_tags_json),\r\n                    label;\r\n\r\n                Jira.labels = [];\r\n\r\n                tags.forEach(function (tag) {\r\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined' ) {\r\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\r\n                        if (label.length < 256) {\r\n                            Jira.labels.push(label);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (error) {\r\n                // Code is not missing here.\r\n            }\r\n        }\r\n    },\r\n\r\n    escapeMarkup: function (str) {\r\n        var length = str.length,\r\n            result = '',\r\n            markup = ['{', '|', '}', '~', '_', '\\\\', '[', ']', '^', '<', '>', '?', '!', '#', '+', '*', '&'];\r\n\r\n        for (var i = 0; i < length; i++) {\r\n            var char = str[i];\r\n\r\n            result += (markup.indexOf(char) !== -1) ? ('&#' + str[i].charCodeAt() + ';') : char;\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            var schema = Jira.getSchema(),\r\n                path = ['projects', 0, 'issuetypes', 0, 'fields'],\r\n                field;\r\n\r\n            while ((field = path.shift()) !== undefined) {\r\n                schema = schema[field];\r\n                if (typeof schema === 'undefined') {\r\n                    schema = null;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (schema) {\r\n                Object.keys(fields)\r\n                    .forEach(function(field) {\r\n                        data.fields[field] = fields[field];\r\n\r\n                        if (typeof schema[field] === 'object' && typeof schema[field].schema === 'object'\r\n                            && (schema[field].schema.type === 'number' || schema[field].schema.type === 'datetime')) {\r\n                            switch (schema[field].schema.type) {\r\n                                case 'number':\r\n                                    data.fields[field] = parseInt(fields[field]);\r\n                                    break;\r\n\r\n                                case 'datetime':\r\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\r\n                                        data.fields[field] = fields[field].replace(/\\./g, '-');\r\n                                    }\r\n                                    else {\r\n                                        delete data.fields[field];\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                    });\r\n            }\r\n            else {\r\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to retrieve field schema.');\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'user', 'password', 'project_key', 'issue_type'].forEach(function (field) {\r\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\r\n                || Jira.params[field] === '' ) {\r\n                throw 'Required Jira param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Jira.params.url + query,\r\n            request = new CurlHttpRequest();\r\n\r\n        request.AddHeader('Content-Type: application/json');\r\n        request.AddHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\r\n\r\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\r\n            request.SetProxy(Jira.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.Log(4, '[ Jira Webhook ] Sending request: ' + url + ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.Get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.Post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.Put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.Log(4, '[ Jira Webhook ] Received response with status code ' + request.Status() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.Log(4, '[ Jira Webhook ] Failed to parse response received from Jira');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.Status() < 200 || request.Status() >= 300) {\r\n            var message = 'Request failed with status code ' + request.Status();\r\n\r\n            if (response !== null && typeof response.errors !== 'undefined'\r\n                && Object.keys(response.errors).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errors);\r\n            }\r\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\r\n                && Object.keys(response.errorMessages).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errorMessages);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.Status(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getSchema: function() {\r\n        var result = Jira.request('get', 'issue/createmeta?expand=projects.issuetypes.fields&projectKeys=' +\r\n                Jira.params.project_key + '&issuetypeNames=' + Jira.params.issue_type);\r\n\r\n        return result.response;\r\n    },\r\n\r\n    createIssue: function(summary, description, fields) {\r\n        var data = {\r\n            fields: {\r\n                project: {\r\n                    key: Jira.params.project_key\r\n                },\r\n                issuetype: {\r\n                    name: Jira.params.issue_type\r\n                },\r\n                summary: summary,\r\n                description: description\r\n            }\r\n        };\r\n\r\n        if (Jira.labels && Jira.labels.length > 0) {\r\n            data.fields.labels = Jira.labels;\r\n        }\r\n        var result = Jira.request('post', 'issue', Jira.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.key === 'undefined') {\r\n            throw 'Cannot create Jira issue. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.key;\r\n    },\r\n\r\n    updateIssue: function(summary, fields, update) {\r\n        var data = {fields: {}};\r\n\r\n        if (summary) {\r\n            data.fields.summary = summary;\r\n        }\r\n\r\n        Jira.request('put', 'issue/' + Jira.params.issue_key, Jira.addCustomFields(data, fields));\r\n        Jira.commentIssue(update);\r\n    },\r\n\r\n    commentIssue: function(update) {\r\n        var data = {};\r\n\r\n        if (typeof update === 'string') {\r\n            data.body = update;\r\n            Jira.request('post', 'issue/' + Jira.params.issue_key + '/comment', data);\r\n        }\r\n        else if (update.status === '1') {\r\n            data.body = update.user + ' ' + update.action + '.';\r\n\r\n            if (update.message) {\r\n                data.body += '\\nMessage: {quote}' + Jira.escapeMarkup(update.message) + '{quote}';\r\n            }\r\n\r\n            Jira.request('post', 'issue/' + Jira.params.issue_key + '/comment', data);\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        jira = {},\r\n        update = {},\r\n        result = {tags: {}},\r\n        required_params = ['alert_subject', 'summary', 'event_recovery_value', 'event_source', 'event_value'];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('jira_')) {\r\n                jira[key.substring(5)] = params[key];\r\n            }\r\n            else if (key.startsWith('customfield_')) {\r\n                fields[key] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    Jira.setParams(jira);\r\n    Jira.setProxy(params.HTTPProxy);\r\n    Jira.setTags(params.event_tags_json);\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        Jira.createIssue(params.alert_subject, params.alert_message);\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && update.status === '0' && !jira.issue_key.startsWith(jira.project_key)) {\r\n        var key = Jira.createIssue(params.alert_subject,\r\n            (Object.keys(fields).length ? params.trigger_description : params.alert_message), fields);\r\n\r\n\r\n        result.tags.__zbx_jira_issuekey = key;\r\n        result.tags.__zbx_jira_issuelink = params.jira_url +\r\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        if (!jira.issue_key.startsWith(jira.project_key)) {\r\n            throw 'Incorrect Issue key given: ' + jira.issue_key;\r\n        }\r\n        Jira.updateIssue(params.alert_subject, fields,\r\n            ((params.event_value === '0' && !Object.keys(fields).length)\r\n                ? params.alert_message : update));\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.Log(3, '[ Jira Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_jira_issuelink}", "event_menu_name": "Jira: {EVENT.TAGS.__zbx_jira_issuekey}", "description": "", "parameters": [{"name": "<'DATETIME' CUSTOMFIELD FOR EVENT RECOVERY TIME>", "value": "{EVENT.RECOVERY.DATE}T{EVENT.RECOVERY.TIME}"}, {"name": "<'DATETIME' CUSTOMFIELD FOR EVENT TIME>", "value": "{EVENT.DATE}T{EVENT.TIME}"}, {"name": "<'NUMBER' CUSTOMFIELD FOR EVENT.ID>", "value": "{EVENT.ID}"}, {"name": "<'NUMBER' CUSTOMFIELD FOR TRIGGER.ID>", "value": "{TRIGGER.ID}"}, {"name": "<'STRING' CUSTOMFIELD FOR HOST\\IP>", "value": "{HOST.HOST} [{HOST.IP}]"}, {"name": "<'STRING' CUSTOMFIELD FOR OPERATIONAL DATA>", "value": "{EVENT.OPDATA}"}, {"name": "<'STRING' CUSTOMFIELD FOR SEVERITY>", "value": "{EVENT.SEVERITY}"}, {"name": "<'URL' CUSTOMFIELD FOR EVENT URL>", "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"}, {"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags_json", "value": "{EVENT.TAGSJSON}"}, {"name": "event_update_action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_update_user", "value": "{USER.FULLNAME}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "jira_issue_key", "value": "{EVENT.TAGS.__zbx_jira_issuekey}"}, {"name": "jira_issue_type", "value": "<PLACE ISSUETYPE NAME>"}, {"name": "jira_password", "value": "<PLACE PASSWORD OR TOKEN>"}, {"name": "jira_project_key", "value": "<PLACE PROJECT KEY>"}, {"name": "jira_url", "value": "<PLACE YOUR JIRA URL>"}, {"name": "jira_user", "value": "<PLACE LOGIN>"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}]}, {"mediatypeid": "14", "type": "4", "name": "MS Teams", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var SEVERITY_COLORS = [\r\n    '#97AAB3', // Not classified.\r\n    '#7499FF', // Information.\r\n    '#FFC859', // Warning.\r\n    '#FFA059', // Average.\r\n    '#E97659', // High.\r\n    '#E45959', // Disaster.\r\n    '#009900', // Resolved.\r\n    '#000000'  // Default.\r\n];\r\n\r\ntry {\r\n    var params = JSON.parse(value);\r\n\r\n    if (typeof params.teams_endpoint !== 'string' || params.teams_endpoint.trim() === '') {\r\n        throw 'Cannot get teams_endpoint';\r\n    }\r\n    else if (!params.teams_endpoint.startsWith('http')) {\r\n        throw 'Invalid MS Teams webhook URL: ' + params.teams_endpoint;\r\n    }\r\n\r\n    params.zabbix_url = (params.zabbix_url.endsWith('/'))\r\n        ? params.zabbix_url.slice(0, -1) : params.zabbix_url;\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    // Set \"use_default_message\" to true for non trigger-based events.\r\n    if (params.event_source !== '0') {\r\n        params.use_default_message = 'true';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n            && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: \"' + params.event_value + '\".\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: \"' + params.event_update_status + '\".\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_value == 0) {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    if (!SEVERITY_COLORS[params.event_nseverity]) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    var request = new HttpRequest(),\r\n        facts = [],\r\n        body = {\r\n            themeColor: SEVERITY_COLORS[params.event_nseverity].replace('#', ''),\r\n            summary: params.alert_subject,\r\n            sections: [\r\n                {\r\n                    markdown: 'false',\r\n                    activityTitle: params.alert_subject,\r\n                    activitySubtitle: 'On ' + params.host_name + ' [' + params.host_ip + ']',\r\n                    text: (params.use_default_message.toLowerCase() == 'true')\r\n                        ? params.alert_message\r\n                        : params.trigger_description\r\n                }\r\n            ],\r\n            potentialAction: [\r\n                {\r\n                    '@type': 'OpenUri',\r\n                    name: (params.event_source === '0')\r\n                        ? 'Event Info'\r\n                        : 'Zabbix Home',\r\n                    targets: [\r\n                        {\r\n                            os: 'default',\r\n                            uri: (params.event_source === '0')\r\n                                ? params.zabbix_url + '/tr_events.php?triggerid=' +\r\n                                    params.trigger_id + '&eventid=' + params.event_id\r\n                                : params.zabbix_url\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        };\r\n\r\n    if (params.use_default_message.toLowerCase() !== 'true') {\r\n        // Problem message.\r\n        if (params.event_value === '1' && params.event_update_status === '0') {\r\n            facts.push({\r\n                name: 'Event time',\r\n                value: params.event_time + ' ' + params.event_date\r\n            });\r\n        }\r\n        // Update message.\r\n        else if (params.event_update_status === '1') {\r\n            body.sections[0].text = params.event_update_user + ' ' + params.event_update_action + '.';\r\n\r\n            if (params.event_update_message) {\r\n                body.sections[0].text += '<br>Message:<br>' + params.event_update_message;\r\n            }\r\n\r\n            facts.push({\r\n                name: 'Event update time',\r\n                value: params.event_update_time + ' ' + params.event_update_date\r\n            });\r\n        }\r\n        // Resolved message.\r\n        else {\r\n            facts.push({\r\n                name: 'Recovery time',\r\n                value: params.event_recovery_time + ' ' + params.event_recovery_date\r\n            });\r\n        }\r\n\r\n        if (params.event_severity && params.event_severity !== '{EVENT.SEVERITY}') {\r\n            facts.push({\r\n                name: 'Severity',\r\n                value: params.event_severity\r\n            });\r\n        }\r\n\r\n\r\n        if (params.event_opdata && params.event_opdata !== '{EVENT.OPDATA}') {\r\n            facts.push({\r\n                name: 'Operational data',\r\n                value: params.event_opdata\r\n            });\r\n        }\r\n\r\n        if (params.event_tags && params.event_tags !== '{EVENT.TAGS}') {\r\n            facts.push({\r\n                name: 'Event tags',\r\n                value: params.event_tags\r\n            });\r\n        }\r\n\r\n        Object.keys(params)\r\n            .forEach(function (key) {\r\n                if (key.startsWith('fact_') && params[key] !== '') {\r\n                    facts.push({\r\n                        name: key.substring(5),\r\n                        value: params[key]\r\n                    });\r\n                }\r\n                else if (key.startsWith('openUri_') && params[key] !== '' && !params[key].startsWith('{')) {\r\n                    body.potentialAction.push({\r\n                        '@type': 'OpenUri',\r\n                        name: key.substring(8),\r\n                        targets: [\r\n                            {\r\n                                os: 'default',\r\n                                uri: params[key]\r\n                            }\r\n                        ]\r\n                    });\r\n                }\r\n            });\r\n        body.sections[0].facts = facts;\r\n    }\r\n\r\n    body.sections[0].text = body.sections[0].text.replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\r\n\r\n    request.addHeader('Content-Type: application/json');\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy !== '') {\r\n        request.setProxy(params.HTTPProxy);\r\n    }\r\n\r\n    Zabbix.log(4, '[ MS Teams Webhook ] JSON: ' + JSON.stringify(body));\r\n\r\n    var response = request.post(params.teams_endpoint, JSON.stringify(body));\r\n\r\n    Zabbix.log(4, '[ MS Teams Webhook ] Response: ' + response);\r\n\r\n    if (response === '1') {\r\n        return 'OK';\r\n    }\r\n    else {\r\n        Zabbix.log(4, '[ MS Teams Webhook ] FAILED with response: ' + response);\r\n        throw response;\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ MS Teams Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_date", "value": "{EVENT.DATE}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_opdata", "value": "{EVENT.OPDATA}"}, {"name": "event_recovery_date", "value": "{EVENT.RECOVERY.DATE}"}, {"name": "event_recovery_time", "value": "{EVENT.RECOVERY.TIME}"}, {"name": "event_severity", "value": "{EVENT.SEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_status", "value": "{EVENT.STATUS}"}, {"name": "event_tags", "value": "{EVENT.TAGS}"}, {"name": "event_time", "value": "{EVENT.TIME}"}, {"name": "event_update_action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "event_update_date", "value": "{EVENT.UPDATE.DATE}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_update_time", "value": "{EVENT.UPDATE.TIME}"}, {"name": "event_update_user", "value": "{USER.FULLNAME}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "host_ip", "value": "{HOST.IP}"}, {"name": "host_name", "value": "{HOST.NAME}"}, {"name": "teams_endpoint", "value": "<PLACE WEBHOOK URL HERE>"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "use_default_message", "value": "false"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "15", "type": "4", "name": "Redmine", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Redmine = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Redmine.params = params;\r\n        if (typeof Redmine.params.url === 'string') {\r\n            if (!Redmine.params.url.endsWith('/')) {\r\n                Redmine.params.url += '/';\r\n            }\r\n        }\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n\r\n            data.issue.custom_fields = [];\r\n            Object.keys(fields)\r\n                .forEach(function (field) {\r\n                    var field_value = fields[field];\r\n\r\n                    if (field_value !== undefined) {\r\n                        data.issue.custom_fields.push({ id: field, value: field_value });\r\n                    }\r\n                });\r\n\r\n        }\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'access_key'].forEach(function (field) {\r\n            if (typeof Redmine.params !== 'object' || typeof Redmine.params[field] === 'undefined'\r\n                || Redmine.params[field] === '' ) {\r\n                throw 'Required param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Redmine.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        if (typeof Redmine.HTTPProxy === 'string' && Redmine.HTTPProxy.trim() !== '') {\r\n            request.setProxy(Redmine.HTTPProxy);\r\n        }\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('X-Redmine-API-Key: ' + Redmine.params.access_key);\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Redmine Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ Redmine Webhook ] Received response with status code ' + request.getStatus() + ': ' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Redmine Webhook ] Failed to parse response received from Redmine');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.errors !== 'undefined'\r\n                && Object.keys(response.errors).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errors);\r\n            }\r\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\r\n                && Object.keys(response.errorMessages).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errorMessages);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getProjectID: function(name) {\r\n        var result = Redmine.request('get', 'projects.json'),\r\n            project_id;\r\n\r\n        if (result.response) {\r\n            var projects = result.response.projects || [];\r\n\r\n            for (var i in projects) {\r\n                if (projects[i].name === name) {\r\n                    project_id = projects[i].id;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            Zabbix.log(4, '[ Redmine Webhook ] Failed to retrieve project data.');\r\n        }\r\n\r\n        if (typeof project_id === 'undefined') {\r\n            throw 'Cannot find project with name: ' + name;\r\n        }\r\n\r\n        return project_id;\r\n    },\r\n\r\n    createIssue: function(subject, description, priority, fields) {\r\n        var project_id = /^\\d+$/.test(Redmine.params.project)\r\n                ? Redmine.params.project\r\n                : Redmine.getProjectID(Redmine.params.project),\r\n            data = {\r\n                issue: {\r\n                    project_id: project_id,\r\n                    tracker_id: Redmine.params.tracker_id,\r\n                    subject: subject,\r\n                    description: description\r\n                }\r\n            },\r\n            result;\r\n\r\n        if (priority) {\r\n            data.issue.priority_id = priority;\r\n        }\r\n\r\n        result = Redmine.request('post', 'issues.json', Redmine.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object'\r\n            || typeof result.response.issue.id === 'undefined'\r\n            || result.status != 201) {\r\n            throw 'Cannot create Redmine issue. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.issue.id;\r\n    },\r\n\r\n    updateIssue: function (note, fields, status) {\r\n        var data = {\r\n            issue: {\r\n                notes: note || ''\r\n            }\r\n        };\r\n\r\n        if (status) {\r\n            data.issue.status_id = status;\r\n        }\r\n\r\n        Redmine.request('put', 'issues/' + Redmine.params.issue_key + '.json', Redmine.addCustomFields(data, fields));\r\n    }\r\n\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        params_redmine = {},\r\n        params_fields = {},\r\n        params_update = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'tracker_id', 'project',\r\n            'event_source', 'event_value',  'event_update_status'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: null, color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('redmine_')) {\r\n                params_redmine[key.substring(8)] = params[key];\r\n            }\r\n            else if (key.startsWith('customfield_')) {\r\n                params_fields[key.substring(12)] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                params_update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n\r\n    if (typeof params_redmine.close_status_id === 'string' && params_redmine.close_status_id.trim() !== '' && !parseInt(params_redmine.close_status_id, 10)) {\r\n        throw 'Incorrect \"redmine_close_status_id\" parameter given! Must be an integer.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (params.event_source === '0'\r\n        && ((params.event_value === '1' && params.event_update_status === '1')\r\n            || (params.event_value === '0'\r\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\r\n        && (isNaN(parseInt(params.redmine_issue_key)) || parseInt(params.redmine_issue_key) < 1 )) {\r\n        throw 'Incorrect \"redmine_issue_key\" parameter given: ' + params.redmine_issue_key +\r\n            '\\nMust be positive integer.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity].name];\r\n    priority = priority && priority.trim() || severities[7].name;\r\n\r\n    Redmine.setParams(params_redmine);\r\n    Redmine.HTTPProxy = params.HTTPProxy;\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0'\r\n        && params.event_value !== '0') {\r\n        Redmine.createIssue(params.alert_subject, params.alert_message, priority);\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && params_update.status === '0') {\r\n        var issue_id = Redmine.createIssue(params.alert_subject,\r\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\r\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\r\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\r\n            priority,\r\n            params_fields);\r\n\r\n        result.tags.__zbx_redmine_issue_id = issue_id;\r\n        result.tags.__zbx_redmine_issuelink = params.redmine_url +\r\n            (params.redmine_url.endsWith('/') ? '' : '/') + 'issues/' + issue_id;\r\n    }\r\n    // Close issue if parameter close_status_id is set and it is a recovery operation\r\n    else if (params.event_value === '0' && typeof params_redmine.close_status_id === 'string' && params_redmine.close_status_id.trim() !== '') {\r\n        Redmine.updateIssue(params.alert_subject + '\\n' + params.alert_message, params_fields, params_redmine.close_status_id);\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        Redmine.updateIssue(params.alert_subject + '\\n' + params.alert_message, params_fields);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Redmine Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_redmine_issuelink}", "event_menu_name": "Redmine: issue #{EVENT.TAGS.__zbx_redmine_issue_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "redmine_access_key", "value": "<PUT YOUR ACCESS KEY>"}, {"name": "redmine_issue_key", "value": "{EVENT.TAGS.__zbx_redmine_issue_id}"}, {"name": "redmine_project", "value": "<PUT YOUR PROJECT ID OR NAME>"}, {"name": "redmine_tracker_id", "value": "<PUT YOUR TRACKER ID>"}, {"name": "redmine_url", "value": "<PUT YOUR REDMINE URL>"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "16", "type": "4", "name": "Telegram", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Telegram = {\r\n    token: null,\r\n    to: null,\r\n    message: null,\r\n    proxy: null,\r\n    parse_mode: null,\r\n\r\n    escapeMarkup: function (str, mode) {\r\n        switch (mode) {\r\n            case 'markdown':\r\n                return str.replace(/([_*\\[`])/g, '\\\\$&');\r\n\r\n            case 'markdownv2':\r\n                return str.replace(/([_*\\[\\]()~`>#+\\-=|{}.!])/g, '\\\\$&');\r\n\r\n            default:\r\n                return str;\r\n        }\r\n    },\r\n\r\n    sendMessage: function () {\r\n        var params = {\r\n            chat_id: Telegram.to,\r\n            text: Telegram.message,\r\n            disable_web_page_preview: true,\r\n            disable_notification: false\r\n        },\r\n        data,\r\n        response,\r\n        request = new HttpRequest(),\r\n        url = 'https://api.telegram.org/bot' + Telegram.token + '/sendMessage';\r\n\r\n        if (Telegram.parse_mode !== null) {\r\n            params['parse_mode'] = Telegram.parse_mode;\r\n        }\r\n\r\n        if (Telegram.proxy) {\r\n            request.setProxy(Telegram.proxy);\r\n        }\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        data = JSON.stringify(params);\r\n\r\n        // Remove replace() function if you want to see the exposed token in the log file.\r\n        Zabbix.log(4, '[Telegram Webhook] URL: ' + url.replace(Telegram.token, '<TOKEN>'));\r\n        Zabbix.log(4, '[Telegram Webhook] params: ' + data);\r\n        response = request.post(url, data);\r\n        Zabbix.log(4, '[Telegram Webhook] HTTP code: ' + request.getStatus());\r\n\r\n        try {\r\n            response = JSON.parse(response);\r\n        }\r\n        catch (error) {\r\n            response = null;\r\n        }\r\n\r\n        if (request.getStatus() !== 200 || typeof response.ok !== 'boolean' || response.ok !== true) {\r\n            if (typeof response.description === 'string') {\r\n                throw response.description;\r\n            }\r\n            else {\r\n                throw 'Unknown error. Check debug log for more information.';\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value);\r\n\r\n    if (typeof params.Token === 'undefined') {\r\n        throw 'Incorrect value is given for parameter \"Token\": parameter is missing';\r\n    }\r\n\r\n    Telegram.token = params.Token;\r\n\r\n    if (params.HTTPProxy) {\r\n        Telegram.proxy = params.HTTPProxy;\r\n    } \r\n\r\n    params.ParseMode = params.ParseMode.toLowerCase();\r\n    \r\n    if (['markdown', 'html', 'markdownv2'].indexOf(params.ParseMode) !== -1) {\r\n        Telegram.parse_mode = params.ParseMode;\r\n    }\r\n\r\n    Telegram.to = params.To;\r\n    Telegram.message = params.Subject + '\\n' + params.Message;\r\n\r\n    if (['markdown', 'markdownv2'].indexOf(params.ParseMode) !== -1) {\r\n        Telegram.message = Telegram.escapeMarkup(Telegram.message, params.ParseMode);\r\n    }\r\n\r\n    Telegram.sendMessage();\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[Telegram Webhook] notification failed: ' + error);\r\n    throw 'Sending failed: ' + error + '.';\r\n}", "timeout": "10s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/media/telegram\r\n\r\n1. Register bot: send \"/newbot\" to @BotFather and follow instructions\r\n2. Copy and paste the obtained token into the \"Token\" field above\r\n3. If you want to send personal notifications, you need to get chat id of the user you want to send messages to:\r\n    3.1. Send \"/getid\" to \"@myidbot\" in Telegram messenger\r\n    3.2. Copy returned chat id and save it in the \"Telegram Webhook\" media for the user\r\n    3.3. Ask the user to send \"/start\" to your bot (Telegram bot won't send anything to the user without it)\r\n4. If you want to send group notifications, you need to get group id of the group you want to send messages to:\r\n    4.1. Add \"@myidbot\" to your group\r\n    4.2. Send \"/getgroupid@myidbot\" in your group\r\n    4.3. Copy returned group id save it in the \"Telegram Webhook\" media for the user you created for  group notifications\r\n    4.4. Send \"/start@your_bot_name_here\" in your group (Telegram bot won't send anything to the group without it)", "parameters": [{"name": "Message", "value": "{ALERT.MESSAGE}"}, {"name": "ParseMode", "value": ""}, {"name": "Subject", "value": "{ALERT.SUBJECT}"}, {"name": "To", "value": "{ALERT.SENDTO}"}, {"name": "Token", "value": "<PLACE YOUR TOKEN>"}]}, {"mediatypeid": "17", "type": "4", "name": "Zendesk", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Zendesk = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Zendesk.params = params;\r\n        if (typeof Zendesk.params.url === 'string') {\r\n            if (!Zendesk.params.url.endsWith('/')) {\r\n                Zendesk.params.url += '/';\r\n            }\r\n            Zendesk.params.url += 'api/v2/';\r\n        }\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            var schema = Zendesk.getSchema(),\r\n                arr = [],\r\n                i,\r\n                n;\r\n\r\n            if (schema) {\r\n                Object.keys(fields)\r\n                    .forEach(function(field) {\r\n                        for (i = 0, n = schema.ticket_fields.length; i < n; i++) {\r\n                            if (schema.ticket_fields[i].id == field\r\n                                && ['text', 'integer', 'date'].indexOf(schema.ticket_fields[i].type) !== -1){\r\n\r\n                                switch (schema.ticket_fields[i].type) {\r\n                                    case 'integer':\r\n                                        fields[field] = parseInt(fields[field]);\r\n                                        break;\r\n                                    case 'date':\r\n                                        if (fields[field].match(/^\\d{4}[.-]\\d{2}[.-]\\d{2}$/) !== null) {\r\n                                            fields[field] = fields[field].replace(/\\./g, '-');\r\n                                        }\r\n                                        else {\r\n                                            fields[field] = '';\r\n                                        }\r\n                                        break;\r\n                                }\r\n\r\n                                arr.push({id: field, value: fields[field]});\r\n                                break;\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                if (arr.length) {\r\n                    data.ticket['custom_fields'] = arr;\r\n                }\r\n            }\r\n            else {\r\n                Zabbix.log(4, '[Zendesk Webhook] Failed to retrieve field schema.');\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'token', 'type'].forEach(function (field) {\r\n            if (typeof Zendesk.params !== 'object' || typeof Zendesk.params[field] === 'undefined') {\r\n                throw 'Required Zendesk param is not set: ' + field + '\\n' + Zendesk.params[field];\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Zendesk.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        if (typeof Zendesk.HTTPProxy === 'string' && Zendesk.HTTPProxy.trim() !== '') {\r\n            request.setProxy(Zendesk.HTTPProxy);\r\n        }\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Basic ' + btoa(Zendesk.params.token));\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[Zendesk Webhook] Sending request: ' + url + ((typeof data === 'string') ? (' ' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[Zendesk Webhook] Received response with status code ' + request.getStatus() + '. ' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[Zendesk Webhook] Failed to parse response received from Zendesk.');\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.error !== 'undefined'\r\n                && Object.keys(response.error).length > 0) {\r\n                message += ': ' + JSON.stringify(response.error);\r\n            }\r\n            else if (response !== null && typeof response.description !== 'undefined'\r\n                && Object.keys(response.description).length > 0) {\r\n                message += ': ' + JSON.stringify(response.description);\r\n            }\r\n            else {\r\n                message += '. ' + response;\r\n            }\r\n            throw message + '. Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getSchema: function() {\r\n        var result = Zendesk.request('get', 'ticket_fields.json');\r\n\r\n        return result.response;\r\n    },\r\n\r\n    createIssue: function(data, fields) {\r\n        var result = Zendesk.request('post', 'tickets.json', Zendesk.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.ticket.id === 'undefined'\r\n            || result.status != 201) {\r\n            throw 'Cannot create Zendesk issue. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.ticket.id;\r\n    },\r\n\r\n    updateIssue: function(data, fields) {\r\n        Zendesk.request('put', 'tickets/' + Zendesk.params.issue_key + '.json', Zendesk.addCustomFields(data, fields));\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        zendesk = {},\r\n        update = {},\r\n        data = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject',\r\n            'alert_message',\r\n            'event_id',\r\n            'event_source',\r\n            'event_value',\r\n            'event_update_status'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: 'default', color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('zendesk_')) {\r\n                zendesk[key.substring(8)] = params[key];\r\n            }\r\n            else if (key.startsWith('customfield_')) {\r\n                fields[key.substring(12)] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter ' + key + ' cannot be empty.';\r\n            }\r\n        });\r\n\r\n    // Possible values: question, incident, problems, task\r\n    if (['question', 'incident', 'problem', 'task'].indexOf(params.zendesk_type) === -1) {\r\n        throw 'Incorrect \"zendesk_type\" parameter given: ' + params.zendesk_type +\r\n            '\\nMust be one of question, incident, problem, task.';\r\n    }\r\n\r\n    // Possible values: 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    // Possible values: 1 for problem, 0 for recovering\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    // Zendesk_issue_key must be a positive integer if an update action is being performed.\r\n    if (params.event_source === '0' && ((params.event_value === '1' && params.event_update_status === '1')\r\n        || (params.event_value === '0' && (params.event_update_status === '0' || params.event_update_status === '1')))\r\n        && (isNaN(parseInt(params.zendesk_issue_key)) || parseInt(params.zendesk_issue_key) < 1 )) {\r\n        throw 'Incorrect \"zendesk_issue_key\" parameter given: ' + params.zendesk_issue_key +\r\n            '\\nMust be positive integer.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity].name] || severities[7].name;\r\n\r\n    Zendesk.setParams(zendesk);\r\n    Zendesk.HTTPProxy = params.HTTPProxy;\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_value !== '0') {\r\n        data = {\r\n            ticket: {\r\n                external_id: params.event_id,\r\n                type: Zendesk.params.type,\r\n                status: 'new',\r\n                subject: params.alert_subject,\r\n                comment: {\r\n                    body: params.alert_message,\r\n                    public: 'false'\r\n                },\r\n                priority: priority,\r\n                tags: params.event_tags\r\n            }\r\n        };\r\n\r\n        Zendesk.createIssue(data, fields);\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && update.status === '0') {\r\n        data = {\r\n            ticket: {\r\n                external_id: params.event_id,\r\n                type: Zendesk.params.type,\r\n                status: 'new',\r\n                subject: params.alert_subject,\r\n                comment: {\r\n                    body: params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/') + 'tr_events.php?triggerid=' +\r\n                        params.trigger_id + '&eventid=' + params.event_id + '\\n' + params.alert_message,\r\n                    public: 'false'\r\n                },\r\n                priority: priority,\r\n                tags: params.event_tags\r\n            }\r\n        };\r\n        var key = Zendesk.createIssue(data, fields);\r\n\r\n        result.tags.__zbx_zdk_issuekey = key;\r\n        result.tags.__zbx_zdk_issuelink = params.zendesk_url +\r\n            (params.zendesk_url.endsWith('/') ? '' : '/') + 'agent/tickets/' + key;\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        data = {\r\n            ticket: {\r\n                type: Zendesk.params.type,\r\n                subject: params.alert_subject,\r\n                comment: {\r\n                    body: params.alert_message,\r\n                    public: 'false'\r\n                }\r\n            }\r\n        };\r\n\r\n        Zendesk.updateIssue(data, fields);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[Zendesk Webhook] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_zdk_issuelink}", "event_menu_name": "Zendesk: {EVENT.TAGS.__zbx_zdk_issuekey}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags", "value": "{EVENT.TAGS}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "severity_average", "value": "normal"}, {"name": "severity_default", "value": "-"}, {"name": "severity_disaster", "value": "urgent"}, {"name": "severity_high", "value": "high"}, {"name": "severity_information", "value": "low"}, {"name": "severity_not_classified", "value": "low"}, {"name": "severity_warning", "value": "normal"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zbxurl", "value": "{$ZABBIX.URL}"}, {"name": "zendesk_issue_key", "value": "{EVENT.TAGS.__zbx_zdk_issuekey}"}, {"name": "zendesk_token", "value": "<put your {enduser_email_address}/token:{api_token}>"}, {"name": "zendesk_type", "value": "incident"}, {"name": "zendesk_url", "value": "<put your Zendesk URL>"}]}, {"mediatypeid": "18", "type": "4", "name": "ServiceNow", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var ServiceNow = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        ServiceNow.params = params;\r\n        if (typeof ServiceNow.params.url === 'string') {\r\n            if (!ServiceNow.params.url.endsWith('/')) {\r\n                ServiceNow.params.url += '/';\r\n            }\r\n\r\n            ServiceNow.params.url += 'api/now/table/incident';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        ServiceNow.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            Object.keys(fields)\r\n                .forEach(function(field) {\r\n                    data[field] = (fields[field].match(/^\\d{4}\\.\\d{2}\\.\\d{2}$/) !== null)\r\n                        ? fields[field].replace(/\\./g, '-')\r\n                        : fields[field];\r\n                });\r\n        }\r\n    },\r\n\r\n    request: function (method, data) {\r\n        ['url', 'user', 'password'].forEach(function (field) {\r\n            if (typeof ServiceNow.params !== 'object' || typeof ServiceNow.params[field] === 'undefined'\r\n                || ServiceNow.params[field] === '' ) {\r\n                throw 'Required ServiceNow param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = ServiceNow.params.url,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Basic ' + btoa(ServiceNow.params.user + ':' + ServiceNow.params.password));\r\n\r\n        if (typeof ServiceNow.HTTPProxy !== 'undefined' && ServiceNow.HTTPProxy !== '') {\r\n            request.setProxy(ServiceNow.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ ServiceNow Webhook ] Sending request: ' + url + ((typeof data === 'string')\r\n            ? ('\\n' + data)\r\n            : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ ServiceNow Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ ServiceNow Webhook ] Failed to parse response received from ServiceNow');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.error.message !== 'undefined'\r\n                && Object.keys(response.error).length > 0) {\r\n                message += ': ' + JSON.stringify(response.error.message);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n        else if (typeof response.result !== 'object' || typeof response.result.sys_id === 'undefined') {\r\n            throw 'Cannot create ServiceNow incident. Check debug log for more information.';\r\n        }\r\n\r\n        return response.result;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        servicenow = {},\r\n        data = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\r\n            'event_update_status', 'event_recovery_value', 'event_nseverity'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: 'default', color: '#000000'}\r\n        ],\r\n        method = 'post',\r\n        process_tags = true;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('servicenow_')) {\r\n                servicenow[key.substring(11)] = params[key];\r\n            }\r\n            else if (key.startsWith('u_')) {\r\n                fields[key] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    data.short_description = params.alert_subject;\r\n    data.description = params.alert_message;\r\n    data.comments = params.alert_message;\r\n\r\n    if (typeof params['urgency_for_' + severities[params.event_nseverity].name] !== 'undefined') {\r\n        data.urgency = params['urgency_for_' + severities[params.event_nseverity].name];\r\n    }\r\n\r\n    ServiceNow.setParams(servicenow);\r\n    ServiceNow.setProxy(params.HTTPProxy);\r\n    ServiceNow.setFields(data, fields);\r\n\r\n    if (params.event_source === '0' && (params.event_value === '0' || params.event_update_status === '1')) {\r\n        process_tags = false;\r\n        method = 'put';\r\n        delete data.description;\r\n        delete data.urgency;\r\n        ServiceNow.params.url += '/' + params.servicenow_sys_id;\r\n    }\r\n\r\n    var response = ServiceNow.request(method, data);\r\n\r\n    if (process_tags) {\r\n        result.tags.__zbx_servicenow_sys_id = response.sys_id;\r\n        result.tags.__zbx_servicenow_link = params.servicenow_url +\r\n            (params.servicenow_url.endsWith('/') ? '' : '/') + 'incident.do?sys_id=' + response.sys_id;\r\n        result.tags.__zbx_servicenow_number = response.number;\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ ServiceNow Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_servicenow_link}", "event_menu_name": "ServiceNow: {EVENT.TAGS.__zbx_servicenow_number}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "servicenow_password", "value": "<PLACE PASSWORD HERE>"}, {"name": "servicenow_sys_id", "value": "{EVENT.TAGS.__zbx_servicenow_sys_id}"}, {"name": "servicenow_url", "value": "{ALERT.SENDTO}"}, {"name": "servicenow_user", "value": "<PLACE USERNAME HERE>"}, {"name": "urgency_for_average", "value": "2"}, {"name": "urgency_for_disaster", "value": "1"}, {"name": "urgency_for_high", "value": "2"}, {"name": "urgency_for_information", "value": "3"}, {"name": "urgency_for_not_classified", "value": "3"}, {"name": "urgency_for_warning", "value": "3"}]}, {"mediatypeid": "19", "type": "4", "name": "Zammad", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Zammad = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Zammad.params = params;\r\n        if (typeof Zammad.params.url === 'string') {\r\n            if (!Zammad.params.url.endsWith('/')) {\r\n                Zammad.params.url += '/';\r\n            }\r\n        }\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'access_token'].forEach(function (field) {\r\n            if (typeof Zammad.params !== 'object' || typeof Zammad.params[field] === 'undefined'\r\n                || Zammad.params[field] === '' ) {\r\n                throw 'Required param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Zammad.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        if (typeof Zammad.HTTPProxy === 'string' && Zammad.HTTPProxy.trim() !== '') {\r\n            request.setProxy(Zammad.HTTPProxy);\r\n        }\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Token token=' + Zammad.params.access_token);\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Zammad Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ Zammad Webhook ] Received response with status code ' + request.getStatus() + ': ' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Zammad Webhook ] Failed to parse response received from Zammad');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.errors !== 'undefined'\r\n                && Object.keys(response.errors).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errors);\r\n            }\r\n            else if (response !== null && typeof response.errorMessages !== 'undefined'\r\n                && Object.keys(response.errorMessages).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errorMessages);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    setTicketTags: function (tags, ticket_id) {\r\n        var data = {\r\n            item: '',\r\n            object: 'Ticket',\r\n            o_id: ticket_id\r\n        };\r\n\r\n        try {\r\n            var tags_json = JSON.parse(tags),\r\n                result;\r\n\r\n            for (var i in tags_json) {\r\n\r\n                if (tags_json[i].value) {\r\n                    data.item = tags_json[i].tag + \": \" + tags_json[i].value;\r\n                } else {\r\n                    data.item = tags_json[i].tag;\r\n                }\r\n                result = Zammad.request('post', 'api/v1/tags/add', data);\r\n\r\n                if (typeof result.response !== 'object' || result.status != 200) {\r\n                    Zabbix.log(4, '[ Zammad Webhook ] Cannot add ticket tag:' + tags_json[i].tag);\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            Zabbix.log(4, '[ Zammad Webhook ] Failed to add ticket tags:' + error);\r\n        }\r\n\r\n        return;\r\n    },\r\n\r\n    createTicket: function(subject, message, priority) {\r\n        var data = {\r\n                title: subject,\r\n                group: 'Users',\r\n                article: {\r\n                    subject: subject,\r\n                    body: message,\r\n                    type: 'note',\r\n                    internal: false\r\n                },\r\n                customer: Zammad.params.customer\r\n            },\r\n            result;\r\n\r\n        if (priority) {\r\n            data.priority_id = priority;\r\n        }\r\n\r\n        result = Zammad.request('post', 'api/v1/tickets', data);\r\n\r\n        if (typeof result.response !== 'object'\r\n            || typeof result.response.id === 'undefined'\r\n            || result.status != 201) {\r\n            throw 'Cannot create Zammad ticket. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.id;\r\n    },\r\n\r\n    updateTicket: function(subject, message) {\r\n        var data = {\r\n            ticket_id: Zammad.params.ticket_id,\r\n            subject: subject,\r\n            body: message || '',\r\n            type: 'note',\r\n            internal: false\r\n        };\r\n\r\n        result = Zammad.request('post', 'api/v1/ticket_articles', data);\r\n\r\n        if (typeof result.response !== 'object'\r\n            || typeof result.response.id === 'undefined'\r\n            || result.status != 201) {\r\n            throw 'Cannot update Zammad ticket. Check debug log for more information.';\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        params_zammad = {},\r\n        params_update = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'customer',\r\n            'event_source', 'event_value',\r\n            'event_update_status'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: null, color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('zammad_')) {\r\n                params_zammad[key.substring(7)] = params[key].trim();\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                params_update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (params.event_source === '0'\r\n        && ((params.event_value === '1' && params.event_update_status === '1')\r\n            || (params.event_value === '0'\r\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\r\n        && (isNaN(parseInt(params.zammad_ticket_id)) || parseInt(params.zammad_ticket_id) < 1 )) {\r\n        throw 'Incorrect \"zammad_ticket_id\" parameter given: ' + params.zammad_ticket_id +\r\n            '\\nMust be positive integer.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity].name];\r\n    priority = priority && priority.trim() || severities[7].name;\r\n\r\n    Zammad.setParams(params_zammad);\r\n    Zammad.HTTPProxy = params.HTTPProxy;\r\n\r\n    // Create ticket for non trigger-based events.\r\n    if (params.event_source !== '0'\r\n        && params.event_value !== '0') {\r\n        Zammad.createTicket(params.alert_subject, params.alert_message, priority, params.event_tags);\r\n    }\r\n    // Create ticket for trigger-based events.\r\n    else if (params.event_value === '1' && params_update.status === '0') {\r\n        var ticket_id = Zammad.createTicket(params.alert_subject,\r\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\r\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\r\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\r\n            priority);\r\n\r\n        result.tags.__zbx_zammad_ticket_id = ticket_id;\r\n        result.tags.__zbx_zammad_ticketlink = params.zammad_url +\r\n            (params.zammad_url.endsWith('/') ? '' : '/') + '#ticket/zoom/' + ticket_id;\r\n\r\n        if (Zammad.params.enable_tags.toLowerCase() === 'true') {\r\n            Zammad.setTicketTags(params.event_tags, ticket_id);\r\n        }\r\n    }\r\n    // Update created ticket for trigger-based event.\r\n    else {\r\n        Zammad.updateTicket(params.alert_subject, params.alert_message);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Zammad Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_zammad_ticketlink}", "event_menu_name": "Zammad: ticket #{EVENT.TAGS.__zbx_zammad_ticket_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags", "value": "{EVENT.TAGSJSON}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}, {"name": "zammad_access_token", "value": "<PUT YOUR ACCESS TOKEN>"}, {"name": "zammad_customer", "value": "<PUT YOUR CUSTOMER EMAIL>"}, {"name": "zammad_enable_tags", "value": "true"}, {"name": "zammad_ticket_id", "value": "{EVENT.TAGS.__zbx_zammad_ticket_id}"}, {"name": "zammad_url", "value": "<PUT YOUR ZAMMAD URL>"}]}, {"mediatypeid": "20", "type": "4", "name": "Jira ServiceDesk", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Jira = {\r\n    params: {},\r\n    schema: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Jira.params = params;\r\n        if (typeof Jira.params.url === 'string') {\r\n            if (!Jira.params.url.endsWith('/')) {\r\n                Jira.params.url += '/';\r\n            }\r\n\r\n            Jira.params.url += 'rest/servicedeskapi/';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Jira.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setTags: function(event_tags_json) {\r\n        if (!Jira.schema) {\r\n            Zabbix.log(4, '[ Jira Service Desk Webhook ] Cannot add labels because failed to retrieve field schema.');\r\n\r\n            return;\r\n        }\r\n\r\n        var block = Jira.schema.requestTypeFields.filter(function(object) {\r\n            return object.fieldId == 'labels';\r\n        });\r\n\r\n        if (block[0] && typeof event_tags_json !== 'undefined' && event_tags_json !== ''\r\n            && event_tags_json !== '{EVENT.TAGSJSON}') {\r\n            try {\r\n                var tags = JSON.parse(event_tags_json),\r\n                    label;\r\n\r\n                Jira.labels = [];\r\n\r\n                tags.forEach(function (tag) {\r\n                    if (typeof tag.tag !== 'undefined' && typeof tag.value !== 'undefined' ) {\r\n                        label = (tag.tag + (tag.value ? (':' + tag.value) : '')).replace(/\\s/g, '_');\r\n                        if (label.length < 255) {\r\n                            Jira.labels.push(label);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (error) {\r\n                // Code is not missing here.\r\n            }\r\n        }\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            if (Jira.schema) {\r\n                Object.keys(fields)\r\n                    .forEach(function(field) {\r\n                        data.requestFieldValues[field] = fields[field];\r\n\r\n                        var block = Jira.schema.requestTypeFields.filter(function(object) {\r\n                            return object.fieldId == field;\r\n                        });\r\n\r\n                        if (typeof block[0] === 'object' && typeof block[0].jiraSchema === 'object'\r\n                            && (block[0].jiraSchema.type === 'number' || block[0].jiraSchema.type === 'datetime')) {\r\n                            switch (block[0].jiraSchema.type) {\r\n                                case 'number':\r\n                                    data.requestFieldValues[field] = parseInt(fields[field]);\r\n                                    break;\r\n\r\n                                case 'datetime':\r\n                                    if (fields[field].match(/\\d+[.-]\\d+[.-]\\d+T\\d+:\\d+:\\d+/) !== null) {\r\n                                        data.requestFieldValues[field] = fields[field].replace(/\\./g, '-');\r\n                                    }\r\n                                    else {\r\n                                        delete data.requestFieldValues[field];\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                    });\r\n            }\r\n            else {\r\n                Zabbix.log(4, '[ Jira Service Desk Webhook ] Cannot add custom fields' +\r\n                    'because failed to retrieve field schema.');\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'user', 'password', 'servicedesk_id', 'request_type_id'].forEach(function (field) {\r\n            if (typeof Jira.params !== 'object' || typeof Jira.params[field] === 'undefined'\r\n                || Jira.params[field] === '' ) {\r\n                throw 'Required Jira param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Jira.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Basic ' + btoa(Jira.params.user + ':' + Jira.params.password));\r\n        request.addHeader('X-ExperimentalApi: opt-in');\r\n\r\n        if (typeof Jira.HTTPProxy !== 'undefined' && Jira.HTTPProxy !== '') {\r\n            request.setProxy(Jira.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Jira Service Desk Webhook ] Sending request: ' + url +\r\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ Jira Service Desk Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Jira Service Desk Webhook ] Failed to parse response received from Jira');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.errors !== 'undefined'\r\n                && Object.keys(response.errors).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errors);\r\n            }\r\n            else if (response !== null && typeof response.errorMessage !== 'undefined'\r\n                && Object.keys(response.errorMessage).length > 0) {\r\n                message += ': ' + JSON.stringify(response.errorMessage);\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    getSchema: function() {\r\n        var result = Jira.request('get', 'servicedesk/' + Jira.params.servicedesk_id + '/requesttype/' +\r\n            Jira.params.request_type_id + '/field');\r\n\r\n        if (typeof Jira.schema !== 'object' && typeof Jira.schema.requestTypeFields !== 'object') {\r\n            Jira.schema = null;\r\n        }\r\n        else {\r\n            Jira.schema = result.response;\r\n        }\r\n    },\r\n\r\n    createRequest: function(summary, description, fields) {\r\n        var data = {\r\n            serviceDeskId: Jira.params.servicedesk_id,\r\n            requestTypeId: Jira.params.request_type_id,\r\n            requestFieldValues: {\r\n                summary: summary,\r\n                description: description\r\n            }\r\n        };\r\n\r\n        if (Jira.labels && Jira.labels.length > 0) {\r\n            data.requestFieldValues.labels = Jira.labels;\r\n        }\r\n        var result = Jira.request('post', 'request', Jira.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.issueKey === 'undefined') {\r\n            throw 'Cannot create Jira request. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.issueKey;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        jira = {},\r\n        comment = {public: true},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\r\n            'event_update_status', 'event_recovery_value'\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('jira_')) {\r\n                jira[key.substring(5)] = params[key];\r\n            }\r\n            else if (key.startsWith('customfield_')) {\r\n                fields[key] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    Jira.setParams(jira);\r\n    Jira.setProxy(params.HTTPProxy);\r\n    Jira.getSchema();\r\n    Jira.setTags(params.event_tags_json);\r\n\r\n    // Create request for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        Jira.createRequest(params.alert_subject, params.alert_message);\r\n    }\r\n    // Create request for trigger-based events.\r\n    else if (params.event_value === '1' && params.event_update_status === '0'\r\n        && jira.request_key === '{EVENT.TAGS.__zbx_jira_requestkey}') {\r\n        var key = Jira.createRequest(params.alert_subject, params.alert_message, fields);\r\n\r\n        result.tags.__zbx_jira_requestkey = key;\r\n        result.tags.__zbx_jira_requestlink = params.jira_url +\r\n            (params.jira_url.endsWith('/') ? '' : '/') + 'browse/' + key;\r\n    }\r\n    // Comment created request for trigger-based event.\r\n    else {\r\n        if (jira.request_key === '{EVENT.TAGS.__zbx_jira_requestkey}' || jira.request_key.trim() === '') {\r\n            throw 'Incorrect Request key given: ' + jira.request_key;\r\n        }\r\n        comment.body = params.alert_message;\r\n        Jira.request('post', 'request/' + Jira.params.request_key + '/comment', comment);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Jira Service Desk Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_jira_requestlink}", "event_menu_name": "Jira ServiceDesk: {EVENT.TAGS.__zbx_jira_requestkey}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_tags_json", "value": "{EVENT.TAGSJSON}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "jira_password", "value": "<PLACE PASSWORD OR TOKEN>"}, {"name": "jira_request_key", "value": "{EVENT.TAGS.__zbx_jira_requestkey}"}, {"name": "jira_request_type_id", "value": "<PLACE REQUEST TYPE ID>"}, {"name": "jira_servicedesk_id", "value": "<PLACE SERVICEDESK ID>"}, {"name": "jira_url", "value": "<PLACE YOUR JIRA URL>"}, {"name": "jira_user", "value": "<PLACE LOGIN>"}]}, {"mediatypeid": "21", "type": "4", "name": "OTRS", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var OTRS = {\r\n    params: {},\r\n    entrypoint: 'nph-genericinterface.pl/Webservice/ZabbixTicketConnector/Ticket',\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        OTRS.params = params;\r\n        if (typeof OTRS.params.url === 'string') {\r\n            if (!OTRS.params.url.endsWith('/')) {\r\n                OTRS.params.url += '/';\r\n            }\r\n        }\r\n    },\r\n\r\n    addDynamicFields: function (data, fields) {\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            data.DynamicField = [];\r\n\r\n            Object.keys(fields)\r\n                .forEach(function(field) {\r\n                    if (field !== undefined) {\r\n                        if (fields[field].match(/^\\d{4}[.-]\\d{2}[.-]\\d{2}$/)) {\r\n                            fields[field] = fields[field].replace(/\\./g, '-');\r\n                        }\r\n\r\n                        data.DynamicField.push({Name: field, Value: fields[field]});\r\n                    }\r\n                });\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'auth_user', 'auth_password', 'queue',\r\n            'customer', 'ticket_state', 'default_priority_id', 'time_unit'].forEach(function (field) {\r\n            if (typeof OTRS.params !== 'object' || typeof OTRS.params[field] === 'undefined'\r\n                || OTRS.params[field] === '' ) {\r\n                throw 'Required param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            request = new HttpRequest(),\r\n            url = OTRS.params.url + query +\r\n                '?UserLogin=' + encodeURIComponent(OTRS.params.auth_user) +\r\n                '&Password=' + encodeURIComponent(OTRS.params.auth_password);\r\n\r\n        if (typeof OTRS.HTTPProxy !== 'undefined' && OTRS.HTTPProxy.trim() !== '') {\r\n            request.setProxy(OTRS.HTTPProxy);\r\n        }\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ OTRS Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ OTRS Webhook ] Received response with status code ' + request.getStatus() + ': ' + response);\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            message += ': ' + response;\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ OTRS Webhook ] Failed to parse response received from OTRS');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (typeof response.Error !== 'undefined'\r\n            && Object.keys(response.Error).length > 0) {\r\n            message = 'Request failed: ' + JSON.stringify(response.Error);\r\n        }\r\n\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    createTicket: function(subject, message, priority, fields) {\r\n        var result,\r\n            data = {\r\n                Ticket: {\r\n                    Title: subject,\r\n                    Queue: OTRS.params.queue,\r\n                    State: OTRS.params.ticket_state,\r\n                    PriorityID: priority || OTRS.params.default_priority_id,\r\n                    CustomerUser: OTRS.params.customer\r\n                },\r\n                Article: {\r\n                    Subject: subject,\r\n                    Body: message,\r\n                    TimeUnit: OTRS.params.time_unit,\r\n                    ContentType: 'text/plain; charset=utf8'\r\n                }\r\n            };\r\n\r\n        result = OTRS.request('post', OTRS.entrypoint, OTRS.addDynamicFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object'\r\n            || typeof result.response.TicketID === 'undefined'\r\n            || result.status != 200) {\r\n            throw 'Cannot create OTRS ticket. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.TicketID;\r\n    },\r\n\r\n    updateTicket: function(subject, message) {\r\n        var result,\r\n            data = {\r\n                Article: {\r\n                    Subject: subject,\r\n                    Body: message || '',\r\n                    TimeUnit: OTRS.params.time_unit,\r\n                    ContentType: 'text/plain; charset=utf8'\r\n                }\r\n            };\r\n\r\n        result = OTRS.request('put', OTRS.entrypoint + '/' + encodeURIComponent(OTRS.params.ticket_id), data);\r\n\r\n        if (typeof result.response !== 'object'\r\n            || typeof result.response.TicketID === 'undefined'\r\n            || result.status != 200) {\r\n            throw 'Cannot update OTRS ticket. Check debug log for more information.';\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        params_otrs = {},\r\n        params_fields = {},\r\n        params_update = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'event_source',\r\n            'event_value',  'event_update_status'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: null, color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('otrs_')) {\r\n                params_otrs[key.substring(5)] = params[key];\r\n            }\r\n            else if (key.startsWith('dynamicfield_')) {\r\n                params_fields[key.substring(13)] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                params_update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (params.event_source === '0'\r\n        && ((params.event_value === '1' && params.event_update_status === '1')\r\n            || (params.event_value === '0'\r\n                && (params.event_update_status === '0' || params.event_update_status === '1')))\r\n        && (isNaN(parseInt(params.otrs_ticket_id)) || parseInt(params.otrs_ticket_id) < 1 )) {\r\n        throw 'Incorrect \"otrs_ticket_id\" parameter given: ' + params.otrs_ticket_id +\r\n            '\\nMust be positive integer.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity].name];\r\n    priority = priority && priority.trim() || severities[7].name;\r\n\r\n    OTRS.setParams(params_otrs);\r\n    OTRS.HTTPProxy = params.HTTPProxy;\r\n\r\n    // Create ticket for non trigger-based events.\r\n    if (params.event_source !== '0'\r\n        && params.event_value !== '0') {\r\n        OTRS.createTicket(params.alert_subject, params.alert_message, priority);\r\n    }\r\n    // Create ticket for trigger-based events.\r\n    else if (params.event_value === '1' && params_update.status === '0') {\r\n        var ticket_id = OTRS.createTicket(params.alert_subject,\r\n            params.alert_subject + '\\n' + params.alert_message + '\\n' +\r\n            params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') +\r\n            'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id + '\\n',\r\n            priority,\r\n            params_fields);\r\n\r\n        result.tags.__zbx_otrs_ticket_id = ticket_id;\r\n        result.tags.__zbx_otrs_ticketlink = params.otrs_url +\r\n            (params.otrs_url.endsWith('/') ? '' : '/') + 'index.pl?Action=AgentTicketZoom;TicketID=' + ticket_id;\r\n    }\r\n    // Update created ticket for trigger-based event.\r\n    else {\r\n        OTRS.updateTicket(params.alert_subject, params.alert_message);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ OTRS Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_otrs_ticketlink}", "event_menu_name": "OTRS: ticket #{EVENT.TAGS.__zbx_otrs_ticket_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "otrs_auth_password", "value": "<PUT YOUR USER PASSWORD>"}, {"name": "otrs_auth_user", "value": "<PUT YOUR USER NAME>"}, {"name": "otrs_customer", "value": "<PUT YOUR CUSTOMER EMAIL>"}, {"name": "otrs_default_priority_id", "value": "3"}, {"name": "otrs_queue", "value": "<PUT YOUR QUEUE NAME>"}, {"name": "otrs_ticket_id", "value": "{EVENT.TAGS.__zbx_otrs_ticket_id}"}, {"name": "otrs_ticket_state", "value": "new"}, {"name": "otrs_time_unit", "value": "0"}, {"name": "otrs_url", "value": "<PUT YOUR OTRS URL>"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "22", "type": "4", "name": "iLert", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "try {\r\n    var result = { tags: {} },\r\n        params = JSON.parse(value),\r\n        req = new HttpRequest(),\r\n        resp = '';\r\n\r\n    if (typeof params.HTTPProxy === 'string' && params.HTTPProxy.trim() !== '') {\r\n        req.setProxy(params.HTTPProxy);\r\n    }\r\n    var alertSourceKey = params['.ILERT.ALERT.SOURCE.KEY'];\r\n    if (!alertSourceKey || (typeof alertSourceKey === 'string' && alertSourceKey.trim() === '')) {\r\n        throw 'incorrect value for variable \"ILERT.ALERT.SOURCE.KEY\". The value must be a non-empty string.';\r\n    }\r\n    delete params['.ILERT.ALERT.SOURCE.KEY'];\r\n    \r\n    var ilertApiBaseURL = \"https://api.ilert.com\";\r\n    var reqURL = encodeURI(ilertApiBaseURL + \"/api/v1/events/zabbix-mt/\" + alertSourceKey)\r\n\r\n    var incidentKey = \"zabbix-\" + params['EVENT.ID'];\r\n    var incidentViewURL = ilertApiBaseURL + \"/api/v1/incidents/resolve-ik/\" + alertSourceKey + \"/\" + incidentKey;\r\n\r\n    req.addHeader('Accept: application/json');\r\n    req.addHeader('Content-Type: application/json');\r\n\r\n    Zabbix.log(4, '[iLert Webhook] Sending request:' + JSON.stringify(params));\r\n    resp = req.post(reqURL, JSON.stringify(params));\r\n    Zabbix.log(4, '[iLert Webhook] Receiving response:' + resp);\r\n\r\n    try {\r\n        resp = JSON.parse(resp);\r\n    }\r\n    catch (error) {\r\n        throw 'incorrect response. iLert returned a non-JSON object.';\r\n    }\r\n\r\n    if (req.getStatus() == 200) {\r\n        result.tags.__ilert_incident_url = incidentViewURL;\r\n        return JSON.stringify(result);\r\n    }\r\n\r\n    if (req.getStatus() == 400 && typeof resp === 'object' && typeof resp.code === 'string') {\r\n        if (resp.code === 'NO_OPEN_INCIDENT_WITH_KEY') {\r\n          return JSON.stringify(result);\r\n        }\r\n        if (resp.code === 'INCIDENT_ALREADY_ACCEPTED') {\r\n          result.tags.__ilert_incident_url = incidentViewURL;\r\n          return JSON.stringify(result);\r\n        }\r\n    }\r\n\r\n    if (typeof resp === 'object' && typeof resp.message === 'string') {\r\n        throw resp.message;\r\n    }\r\n    else {\r\n        throw 'Unknown error.';\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[iLert Webhook] Notification failed : ' + error);\r\n    throw 'iLert notification failed : ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__ilert_incident_url}", "event_menu_name": "iLert incident", "description": "Please refer to https://docs.ilert.com/integrations/zabbix/native \r\n  \r\nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\r\nAdd a dedicated user with the media type \"iLert\". You can also rewrite the incident summary via \".ILERT.INCIDENT.SUMMARY\" parameter or leave it empty to use the standard pattern.", "parameters": [{"name": ".ILERT.ALERT.SOURCE.KEY", "value": "{ALERT.SENDTO}"}, {"name": ".ILERT.INCIDENT.SUMMARY", "value": ""}, {"name": "ALERT.MESSAGE", "value": "{ALERT.MESSAGE}"}, {"name": "ALERT.SUBJECT", "value": "{ALERT.SUBJECT}"}, {"name": "EVENT.ACK.STATUS", "value": "{EVENT.ACK.STATUS}"}, {"name": "EVENT.DATE", "value": "{EVENT.DATE}"}, {"name": "EVENT.ID", "value": "{EVENT.ID}"}, {"name": "EVENT.NAME", "value": "{EVENT.NAME}"}, {"name": "EVENT.NSEVERITY", "value": "{EVENT.NSEVERITY}"}, {"name": "EVENT.OPDATA", "value": "{EVENT.OPDATA}"}, {"name": "EVENT.RECOVERY.DATE", "value": "{EVENT.RECOVERY.DATE}"}, {"name": "EVENT.RECOVERY.TIME", "value": "{EVENT.RECOVERY.TIME}"}, {"name": "EVENT.RECOVERY.VALUE", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "EVENT.SEVERITY", "value": "{EVENT.SEVERITY}"}, {"name": "EVENT.TAGS", "value": "{EVENT.TAGS}"}, {"name": "EVENT.TIME", "value": "{EVENT.TIME}"}, {"name": "EVENT.UPDATE.ACTION", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "EVENT.UPDATE.DATE", "value": "{EVENT.UPDATE.DATE}"}, {"name": "EVENT.UPDATE.MESSAGE", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "EVENT.UPDATE.STATUS", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "EVENT.UPDATE.TIME", "value": "{EVENT.UPDATE.TIME}"}, {"name": "EVENT.VALUE", "value": "{EVENT.VALUE}"}, {"name": "HOST.HOST", "value": "{HOST.HOST}"}, {"name": "HOST.IP", "value": "{HOST.IP}"}, {"name": "HOST.NAME", "value": "{HOST.NAME}"}, {"name": "ITEM.ID1", "value": "{ITEM.ID1}"}, {"name": "ITEM.ID2", "value": "{ITEM.ID2}"}, {"name": "ITEM.ID3", "value": "{ITEM.ID3}"}, {"name": "ITEM.ID4", "value": "{ITEM.ID4}"}, {"name": "ITEM.ID5", "value": "{ITEM.ID5}"}, {"name": "ITEM.NAME1", "value": "{ITEM.NAME1}"}, {"name": "ITEM.NAME2", "value": "{ITEM.NAME2}"}, {"name": "ITEM.NAME3", "value": "{ITEM.NAME3}"}, {"name": "ITEM.NAME4", "value": "{ITEM.NAME4}"}, {"name": "ITEM.NAME5", "value": "{ITEM.NAME5}"}, {"name": "TRIGGER.DESCRIPTION", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "TRIGGER.ID", "value": "{TRIGGER.ID}"}, {"name": "TRIGGER.NAME", "value": "{TRIGGER.NAME}"}, {"name": "TRIGGER.SEVERITY", "value": "{TRIGGER.SEVERITY}"}, {"name": "TRIGGER.STATUS", "value": "{TRIGGER.STATUS}"}, {"name": "TRIGGER.URL", "value": "{TRIGGER.URL}"}, {"name": "TRIGGER.VALUE", "value": "{TRIGGER.VALUE}"}, {"name": "USER.FULLNAME", "value": "{USER.FULLNAME}"}, {"name": "ZABBIX.URL", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "23", "type": "4", "name": "SolarWinds Service Desk", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var SolarWinds = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        SolarWinds.params = params;\r\n        SolarWinds.params.endpoint = 'https://api.samanage.com/';\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        SolarWinds.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    addCustomFields: function (data, fields) {\r\n        if (typeof data.incident === 'object' && typeof fields === 'object' && Object.keys(fields).length) {\r\n            if (typeof fields.sw_fields === 'object' && Object.keys(fields.sw_fields).length) {\r\n                Object.keys(fields.sw_fields)\r\n                    .forEach(function(field) {\r\n                        try {\r\n                            data.incident[field] = JSON.parse(fields.sw_fields[field]);\r\n                        }\r\n                        catch (error) {\r\n                            data.incident[field] = fields.sw_fields[field];\r\n                        }\r\n                    });\r\n            }\r\n\r\n            if (typeof fields.sw_customfields === 'object' && Object.keys(fields.sw_customfields).length) {\r\n                data.incident.custom_fields_values = {custom_fields_value: []};\r\n                Object.keys(fields.sw_customfields)\r\n                    .forEach(function(field) {\r\n                        data.incident.custom_fields_values.custom_fields_value.push({\r\n                            name: field,\r\n                            value: fields.sw_customfields[field]\r\n                        });\r\n                    });\r\n            }\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['token'].forEach(function (field) {\r\n            if (typeof SolarWinds.params !== 'object' || typeof SolarWinds.params[field] === 'undefined'\r\n                || SolarWinds.params[field] === '' ) {\r\n                throw 'Required SolarWinds param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = SolarWinds.params.endpoint + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('X-Samanage-Authorization: Bearer ' + SolarWinds.params.token);\r\n        request.addHeader('Accept: application/vnd.samanage.v2.1+json');\r\n\r\n        if (typeof SolarWinds.HTTPProxy !== 'undefined' && SolarWinds.HTTPProxy !== '') {\r\n            request.setProxy(SolarWinds.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ SolarWinds SD Webhook ] Sending request: ' + url + ((typeof data === 'string')\r\n            ? ('\\n' + data)\r\n            : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ SolarWinds SD Webhook ] Received response with status code ' + request.getStatus() +\r\n            '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ SolarWinds SD Webhook ] Failed to parse response received from SolarWinds');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.error !== 'undefined'\r\n                && Object.keys(response.error).length > 0) {\r\n                message += ': ' + JSON.stringify(response.error);\r\n            }\r\n            else if (response !== null && typeof response === 'object'\r\n                && Object.keys(response).length > 0) {\r\n                Object.keys(response)\r\n                    .forEach(function(field) {\r\n                        message += '\\n' + field + ': ' + response[field][0];\r\n                    });\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    createIncident: function(name, description, fields) {\r\n        var data = {\r\n            incident: {\r\n                name: name,\r\n                description: description,\r\n                priority: SolarWinds.params.priority\r\n            }\r\n        };\r\n\r\n        var result = SolarWinds.request('post', 'incidents.json', SolarWinds.addCustomFields(data, fields));\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.id === 'undefined') {\r\n            throw 'Cannot create SolarWinds incident. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.id;\r\n    },\r\n\r\n    updateIncident: function(name, fields, message) {\r\n        var data = {\r\n            incident: {\r\n                name: name,\r\n                priority: SolarWinds.params.priority\r\n            }\r\n        };\r\n\r\n        SolarWinds.request(\r\n            'put',\r\n            'incidents/' + SolarWinds.params.incident_id + '.json',\r\n            SolarWinds.addCustomFields(data, fields));\r\n\r\n        SolarWinds.commenIncident(message);\r\n    },\r\n\r\n    commenIncident: function(message) {\r\n        var data = {\r\n            comment: {\r\n                body: message\r\n            }\r\n        };\r\n\r\n        SolarWinds.request('post', 'incidents/' + SolarWinds.params.incident_id + '/comments.json', data);\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        samanage = {},\r\n        result = {tags: {}},\r\n        required_params = ['alert_subject', 'event_recovery_value', 'event_source', 'event_value', 'priority_default'],\r\n        severities = [\r\n            {name: 'not_classified'},\r\n            {name: 'information'},\r\n            {name: 'warning'},\r\n            {name: 'average'},\r\n            {name: 'high'},\r\n            {name: 'disaster'},\r\n            {name: 'resolved'},\r\n            {name: 'default'}\r\n        ];\r\n\r\n    fields.sw_fields = {};\r\n    fields.sw_customfields = {};\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('samanage_')) {\r\n                samanage[key.substring(9)] = params[key];\r\n            }\r\n            else if (key.startsWith('sw_field_')) {\r\n                fields.sw_fields[key.substring(9)] = params[key];\r\n            }\r\n            else if (key.startsWith('sw_customfield_')) {\r\n                fields.sw_customfields[key.substring(15)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    samanage.priority = params['priority_' + severities[params.event_nseverity].name] || params.priority_default;\r\n\r\n    SolarWinds.setParams(samanage);\r\n    SolarWinds.setProxy(params.HTTPProxy);\r\n\r\n    // Create incident for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        SolarWinds.createIncident(params.alert_subject, params.alert_message);\r\n    }\r\n    // Create incident for trigger-based events.\r\n    else if (params.event_value === '1' && params.event_update_status === '0'\r\n            && samanage.incident_id === '{EVENT.TAGS.__zbx_solarwinds_inc_id}') {\r\n        var key = SolarWinds.createIncident(params.alert_subject, params.alert_message, fields);\r\n\r\n\r\n        result.tags.__zbx_solarwinds_inc_id = key;\r\n        result.tags.__zbx_solarwinds_inc_link = params.samanage_url +\r\n            (params.samanage_url.endsWith('/') ? '' : '/') + 'incidents/' + key;\r\n    }\r\n    // Update created incident for trigger-based event.\r\n    else {\r\n        if (samanage.incident_id === '{EVENT.TAGS.__zbx_solarwinds_inc_id}' || samanage.incident_id === '') {\r\n            throw 'Incorrect incident key given: ' + samanage.incident_id;\r\n        }\r\n        if (!params.alert_message) {\r\n            throw 'Parameter \"alert_message\" can\\'t be empty.';\r\n        }\r\n        SolarWinds.updateIncident(params.alert_subject, fields, params.alert_message);\r\n    }\r\n\r\n    if (params.event_source === '0') {\r\n        return JSON.stringify(result);\r\n    }\r\n    else {\r\n        return 'OK';\r\n    }\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ SolarWinds SD Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_solarwinds_inc_link}", "event_menu_name": "SolarWinds incident ID: {EVENT.TAGS.__zbx_solarwinds_inc_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "priority_average", "value": "Medium"}, {"name": "priority_default", "value": "Low"}, {"name": "priority_disaster", "value": "Critical"}, {"name": "priority_high", "value": "High"}, {"name": "samanage_incident_id", "value": "{EVENT.TAGS.__zbx_solarwinds_inc_id}"}, {"name": "samanage_token", "value": "<PUT YOUR TOKEN HERE>"}, {"name": "samanage_url", "value": "<PUT YOUR INSTANCE URL HERE>"}]}, {"mediatypeid": "24", "type": "4", "name": "SysAid", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var SysAid = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        var required = ['url', 'auth_user', 'auth_password', 'category_level_1', 'category_level_2',\r\n            'category_level_3', 'incident_id', 'template_id', 'urgency_id', 'incident_state',\r\n            'default_priority_id'\r\n        ];\r\n\r\n        required.forEach(function (field) {\r\n            if (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\r\n                throw 'Required param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        SysAid.params = params;\r\n        if (typeof SysAid.params.url === 'string' && !SysAid.params.url.endsWith('/')) {\r\n            SysAid.params.url += '/';\r\n        }\r\n    },\r\n\r\n    login: function () {\r\n        var result = SysAid.request('post', 'api/v1/login', {\r\n            user_name: SysAid.params.auth_user,\r\n            password: SysAid.params.auth_password\r\n        });\r\n\r\n        return result.response.user.id;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        var response,\r\n            request = SysAid.req || (SysAid.req = new HttpRequest()),\r\n            url = SysAid.params.url + query;\r\n\r\n        if (typeof SysAid.HTTPProxy !== 'undefined' && SysAid.HTTPProxy.trim() !== '') {\r\n            request.setProxy(SysAid.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ SysAid Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? (' ' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ SysAid Webhook ] Received response with status code ' + request.getStatus() + ': ' + response);\r\n\r\n        if (request.getStatus() !== 200) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            message += ': ' + response;\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ SysAid Webhook ] Failed to parse response received from SysAid');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (response === null || (typeof response.Error !== 'undefined' && Object.keys(response.Error).length > 0)) {\r\n            throw 'Request failed: ' + JSON.stringify(response.Error);\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    createIncident: function(subject, message, priority) {\r\n        var result = SysAid.request('post', 'api/v1/sr/?template=' + encodeURIComponent(SysAid.params.template_id), {\r\n            info: [\r\n                {\r\n                    key: 'problem_type',\r\n                    value: [\r\n                        SysAid.params.category_level_1,\r\n                        SysAid.params.category_level_2,\r\n                        SysAid.params.category_level_3\r\n                    ].join('_')\r\n                },\r\n                {\r\n                    key: 'title',\r\n                    value: subject\r\n                },\r\n                {\r\n                    key: 'description',\r\n                    value: message\r\n                },\r\n                {\r\n                    key: 'status',\r\n                    value: '1'\r\n                },\r\n                {\r\n                    key: 'urgency',\r\n                    value: SysAid.params.urgency_id\r\n                },\r\n                {\r\n                    key: 'priority',\r\n                    value: priority || SysAid.params.default_priority_id,\r\n                }\r\n            ]\r\n        });\r\n\r\n        if (result.response.id === 'undefined') {\r\n            throw 'Cannot create SysAid incident. Check debug log for more information.';\r\n        }\r\n\r\n        return result.response.id;\r\n    },\r\n\r\n    updateTicket: function(note) {\r\n        var date = new Date().getTime();\r\n\r\n        SysAid.request('put', 'api/v1/sr/' + encodeURIComponent(SysAid.params.incident_id), {\r\n            id: SysAid.params.incident_id,\r\n            info: [\r\n                {\r\n                    key: 'update_time',\r\n                    value: date\r\n                },\r\n                {\r\n                    key: 'notes',\r\n                    value: [\r\n                        {\r\n                            userName: 'Zabbix',\r\n                            createDate: date,\r\n                            text: note\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        });\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        params_sysaid = {},\r\n        params_update = {},\r\n        result = {tags: {}},\r\n        required_params = ['alert_subject', 'event_source', 'event_value',  'event_update_status'],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: null, color: '#000000'}\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('sysaid_')) {\r\n                params_sysaid[key.substring(7)] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                params_update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (params.event_source === '0' && ((params.event_value === '1' && params.event_update_status === '1')\r\n            || (params.event_value === '0' && (params.event_update_status === '0' || params.event_update_status === '1')))\r\n            && (isNaN(parseInt(params.sysaid_incident_id)) || parseInt(params.sysaid_incident_id) < 1 )) {\r\n        throw 'Incorrect \"sysaid_incident_id\" parameter given: ' + params.sysaid_incident_id + '\\nMust be positive integer.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity].name];\r\n    priority = priority && priority.trim() || severities[7].name;\r\n\r\n    SysAid.setParams(params_sysaid);\r\n    SysAid.HTTPProxy = params.HTTPProxy;\r\n    SysAid.login();\r\n\r\n    if (params.event_source !== '0' && params.event_value !== '0') {\r\n        // Create ticket for non trigger-based events.\r\n        SysAid.createIncident(params.alert_subject, params.alert_message, priority);\r\n    }\r\n    else if (params.event_value === '1' && params_update.status === '0') {\r\n        // Create ticket for trigger-based events.\r\n        var incident_id = SysAid.createIncident(params.alert_subject, params.alert_subject + '\\n' + params.alert_message +\r\n                '\\n' + params.zabbix_url + (params.zabbix_url.endsWith('/') ? '' : '/') + 'tr_events.php?triggerid=' +\r\n                params.trigger_id + '&eventid=' + params.event_id + '\\n', priority\r\n        );\r\n\r\n        result.tags.__zbx_sysaid_incident_id = incident_id;\r\n        result.tags.__zbx_sysaid_incidentlink = params.sysaid_url +\r\n            (params.sysaid_url.endsWith('/') ? '' : '/') + 'SREdit.jsp?id=' + incident_id + '&fromId=IncidentsList';\r\n    }\r\n    else {\r\n        // Update created ticket for trigger-based event.\r\n        SysAid.updateTicket(params.alert_subject + '\\n' + params.alert_message);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ SysAid Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_sysaid_incidentlink}", "event_menu_name": "SysAid: incident #{EVENT.TAGS.__zbx_sysaid_incident_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "sysaid_auth_password", "value": "<PUT YOUR USER PASSWORD>"}, {"name": "sysaid_auth_user", "value": "<PUT YOUR USER NAME>"}, {"name": "sysaid_category_level_1", "value": "<PUT YOUR CATEGORY>"}, {"name": "sysaid_category_level_2", "value": "<PUT YOUR SUB-CATEGORY>"}, {"name": "sysaid_category_level_3", "value": "<PUT YOUR THIRD LEVEL CATEGORY>"}, {"name": "sysaid_default_priority_id", "value": "1"}, {"name": "sysaid_incident_id", "value": "{EVENT.TAGS.__zbx_sysaid_incident_id}"}, {"name": "sysaid_incident_state", "value": "1"}, {"name": "sysaid_template_id", "value": "<PUT YOUR TEMPLATE ID>"}, {"name": "sysaid_urgency_id", "value": "<PUT YOUR URGENCY ID>"}, {"name": "sysaid_url", "value": "<PUT YOUR SYSAID URL>"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "25", "type": "4", "name": "TOPdesk", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Media = {\r\n    params: {},\r\n    name: '',\r\n    labels: [],\r\n    HTTPProxy: '',\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Media.params = params;\r\n        Media.params.api += Media.params.api.endsWith('/') ? '' : '/';\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        if (typeof HTTPProxy !== 'undefined' && HTTPProxy.trim() !== '') {\r\n            Media.HTTPProxy = HTTPProxy;\r\n        }\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['api', 'token'].forEach(function (field) {\r\n            if (typeof Media.params !== 'object' || typeof Media.params[field] === 'undefined'\r\n                    || Media.params[field] === '') {\r\n                throw 'Required ' + Media.name + ' param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Media.params.api + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Accept: application/json');\r\n        request.addHeader('Authorization: ' + Media.params.token);\r\n        request.setProxy(Media.HTTPProxy);\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Sending request: ' +\r\n            url + ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Failed to parse response.');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null) {\r\n                if (typeof response.errors === 'object' && Object.keys(response.errors).length > 0) {\r\n                    message += ': ' + JSON.stringify(response.errors);\r\n                }\r\n                else if (typeof response.errorMessages === 'object' && Object.keys(response.errorMessages).length > 0) {\r\n                    message += ': ' + JSON.stringify(response.errorMessages);\r\n                }\r\n                else if (typeof response.message === 'string') {\r\n                    message += ': ' + response.message;\r\n                }\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    }\r\n};\r\n\r\ntry {\r\n    var result = {tags: {}},\r\n        params = JSON.parse(value),\r\n        media = {},\r\n        fields = {},\r\n        resp = {},\r\n        required_params = [\r\n            'alert_subject',\r\n            'alert_message',\r\n            'event_id',\r\n            'event_source',\r\n            'event_value',\r\n            'event_update_status',\r\n            'topdesk_api',\r\n            'topdesk_user',\r\n            'topdesk_password'\r\n        ],\r\n        severities = [\r\n            'not_classified',\r\n            'information',\r\n            'warning',\r\n            'average',\r\n            'high',\r\n            'disaster',\r\n            'resolved',\r\n            'default'\r\n        ],\r\n        priority;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" cannot be empty.';\r\n            }\r\n            if (key.startsWith('topdesk_')) {\r\n                media[key.substring(8)] = params[key];\r\n            }\r\n        });\r\n\r\n    // Possible values of event_source:\r\n    // 0 - Trigger, 1 - Discovery, 2 - Autoregistration, 3 - Internal.\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: \"' + params.event_source + '\".\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check event_value for trigger-based and internal events.\r\n    // Possible values: 1 for problem, 0 for recovering\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check event_update_status only for trigger-based events.\r\n    // Possible values: 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\r\n    if (params.event_source === '0' && params.event_update_status !== '0' && params.event_update_status !== '1') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check event_id for a numeric value.\r\n    if (isNaN(parseInt(params.event_id)) || params.event_id < 1) {\r\n        throw 'Incorrect \"event_id\" parameter given: ' + params.event_id + '\\nMust be a positive number.';\r\n    }\r\n\r\n    if ((params.event_source === '1' || params.event_source === '2')  && params.event_value === '0') {\r\n        throw 'Recovery operations are supported only for Trigger and Internal actions.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    priority = params['severity_' + severities[params.event_nseverity]];\r\n    params.zbxurl = params.zbxurl + (params.zbxurl.endsWith('/') ? '' : '/');\r\n\r\n    Media.name = 'TOPdesk';\r\n    Media.setParams(media);\r\n    Media.params.token = 'Basic ' + btoa(Media.params.user + ':' + Media.params.password);\r\n    Media.setProxy(params.HTTPProxy);\r\n\r\n    // Create an issue.\r\n    // Numeric value of the event that triggered an action (1 for problem, 0 for recovering).\r\n    // Numeric value of the problem update status. Possible values:\r\n    // 0 - Webhook was called because of problem/recovery event, 1 - Update operation.\r\n    if ((params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0)\r\n            || (params.event_source == 3 && params.event_value == 1)\r\n            || params.event_source == 1 || params.event_source == 2) {\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Request of the ticket creating.');\r\n        fields.caller = {dynamicName: 'Zabbix'};\r\n        fields.briefDescription = params.alert_subject;\r\n        fields.request = params.alert_message.replace(/\\n/g, '<br>');\r\n        fields.priority = {name: priority};\r\n        fields.processingStatus = {name: Media.params.status};\r\n        fields.externalNumber = params.event_id;\r\n        fields.request += '<br>' + params.zbxurl;\r\n\r\n        if (params.event_source === '0') {\r\n            fields.request += 'tr_events.php?triggerid=' + params.trigger_id + '&eventid=' + params.event_id;\r\n        }\r\n\r\n        resp = Media.request('post', 'tas/api/incidents', fields);\r\n        if (typeof resp.response !== 'object' || typeof resp.response.id === 'undefined') {\r\n            throw 'Cannot create ' + Media.name + ' issue. Check debug log for more information.';\r\n        }\r\n\r\n        if (params.event_source == 0 && params.event_value == 1 && params.event_update_status == 0) {\r\n            result.tags.__zbx_tpd_issuekey = resp.response.number;\r\n            result.tags.__zbx_tpd_issuelink = Media.params.api +\r\n                'tas/secure/incident?action=show&unid=' + resp.response.id;\r\n        }\r\n    }\r\n    // Update a created issue.\r\n    else {\r\n        if (params.event_source == 3 && params.event_value == 0) {\r\n            throw 'Internal event recovery actions are not supported.';\r\n        }\r\n\r\n        Zabbix.log(4, '[ ' + Media.name + ' Webhook ] Request of the ticket updating.');\r\n        fields.action = params.alert_message.replace(/\\n/g, '<br>');\r\n\r\n        resp = Media.request('put', 'tas/api/incidents/number/' + Media.params.issue_key, fields);\r\n        if (typeof resp.response !== 'object' || typeof resp.response.id === 'undefined'\r\n                || resp.response.number !== Media.params.issue_key) {\r\n            throw 'Cannot update ' + Media.name + ' issue. Check debug log for more information.';\r\n        }\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ ' + Media.name + ' Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_tpd_issuelink}", "event_menu_name": "TOPdesk: {EVENT.TAGS.__zbx_tpd_issuekey}", "description": "Please refer to https://developers.topdesk.com/documentation/index.html and https://www.zabbix.com/documentation/6.0/manual/config/notifications/media/webhook#example_scripts.\r\n  \r\nSet global macro {$ZABBIX.URL} with your Zabbix server URL.\r\nAdd a dedicated user with the media type \"TOPdesk\".\r\nChange the values of the variables topdesk_api (URL), topdesk_password, topdesk_user. The topdesk_status is the default status for creating a new TOPdesk ticket.", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "severity_average", "value": "P3"}, {"name": "severity_default", "value": "P5"}, {"name": "severity_disaster", "value": "P1"}, {"name": "severity_high", "value": "P2"}, {"name": "severity_information", "value": "P5"}, {"name": "severity_not_classified", "value": "P5"}, {"name": "severity_warning", "value": "P4"}, {"name": "topdesk_api", "value": "<put your TOPdesk API URL>"}, {"name": "topdesk_issue_key", "value": "{EVENT.TAGS.__zbx_tpd_issuekey}"}, {"name": "topdesk_password", "value": "<put your TOPdesk application password>"}, {"name": "topdesk_status", "value": "<put default status for new tickets>"}, {"name": "topdesk_user", "value": "<put your TOPdesk username>"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zbxurl", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "26", "type": "4", "name": "iTop", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Itop = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        if (params.log !== 'private_log' && params.log !== 'public_log') {\r\n            throw 'Incorrect \"itop_log\" parameter given: ' + params.log + '\\nMust be \"private_log\" or \"public_log\".';\r\n        }\r\n\r\n        Itop.params = params;\r\n        if (typeof Itop.params.url === 'string') {\r\n            if (!Itop.params.url.endsWith('/')) {\r\n                Itop.params.url += '/';\r\n            }\r\n\r\n            Itop.params.url += 'webservices/rest.php?version=' + encodeURIComponent(Itop.params.api_version);\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Itop.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setCreatePayload: function () {\r\n        json_data.operation = 'core/create';\r\n        json_data.fields.org_id = Itop.params.organization_id;\r\n        json_data.fields.title = params.alert_subject;\r\n        json_data.fields.description = params.alert_message.replace('<', '&lt;')\r\n            .replace('>', '&gt;')\r\n            .replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\r\n    },\r\n\r\n    setUpdatePayload: function () {\r\n        json_data.operation = 'core/update';\r\n        json_data.key = Itop.params.id;\r\n        json_data.fields.title = params.alert_subject;\r\n        json_data.fields[Itop.params.log] = {\r\n            add_item: {\r\n                message: params.alert_subject + '\\n' + params.alert_message,\r\n                format: 'text'\r\n            }\r\n        };\r\n    },\r\n\r\n    request: function (data) {\r\n        ['url', 'user', 'password', 'organization_id', 'class', 'api_version', 'id'].forEach(function (field) {\r\n            if (typeof Itop.params !== 'object' || typeof Itop.params[field] === 'undefined'\r\n                    || Itop.params[field] === '' ) {\r\n                throw 'Required Itop param is not set: \"itop_' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = Itop.params.url,\r\n            request = new HttpRequest(),\r\n            object;\r\n\r\n        request.addHeader('Content-Type: multipart/form-data');\r\n        request.addHeader('Authorization: Basic ' + btoa(Itop.params.user + ':' + Itop.params.password));\r\n\r\n        if (Itop.HTTPProxy) {\r\n            request.setProxy(Itop.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ iTop Webhook ] Sending request: ' + url + '&json_data=' + data);\r\n\r\n        response = request.post(url + '&json_data=' + encodeURIComponent(data));\r\n\r\n        Zabbix.log(4, '[ iTop Webhook ] Received response with status code ' + request.getStatus() + '\\n' + response);\r\n\r\n        try {\r\n            response = JSON.parse(response);\r\n        }\r\n        catch (error) {\r\n            Zabbix.log(4, '[ iTop Webhook ] Failed to parse response received from iTop');\r\n            throw 'Failed to parse response received from iTop.\\nRequest status code ' +\r\n                    request.getStatus() + '. Check debug log for more information.';\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            throw 'Request failed with status code ' + request.getStatus() + '. Check debug log for more information.';\r\n        }\r\n        else if (typeof response.code !== 'undefined' && response.code !== 0) {\r\n            throw 'Request failed with iTop code ' + response.code + ': ' +\r\n                    JSON.stringify(response.message) + '. Check debug log for more information.';\r\n        }\r\n        else {\r\n            Object.keys(response.objects)\r\n                .forEach(function (key) {\r\n                    object = response.objects[key];\r\n                });\r\n    \r\n            return {\r\n                status: request.getStatus(),\r\n                response: object.fields\r\n            };\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        json_data = {},\r\n        itop_params = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'alert_subject', 'summary', 'event_recovery_value',\r\n            'event_source', 'event_value', 'action_name'\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('itop_')) {\r\n                itop_params[key.substring(5)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n            && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    Itop.setParams(itop_params);\r\n    Itop.setProxy(params.HTTPProxy);\r\n\r\n    json_data.operation = '';\r\n    json_data.class = Itop.params.class;\r\n    json_data.comment = Itop.params.comment;\r\n    json_data.output_fields = 'id, friendlyname';\r\n    json_data.fields = {};\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        Itop.setCreatePayload();\r\n        Itop.request(json_data);\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && params.event_update_status === '0'\r\n            && Itop.params.id === '{EVENT.TAGS.__zbx_itop_id}') {\r\n        Itop.setCreatePayload();\r\n\r\n        var response = Itop.request(json_data);\r\n\r\n        result.tags.__zbx_itop_id = response.response.id;\r\n        result.tags.__zbx_itop_key = response.response.friendlyname;\r\n        result.tags.__zbx_itop_link = params.itop_url + (params.itop_url.endsWith('/') ? '' : '/') +\r\n                'pages/UI.php?operation=details&class=' + encodeURIComponent(Itop.params.class) + '&id=' +\r\n                encodeURIComponent(response.response.id);\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        if (Itop.params.id === '{EVENT.TAGS.__zbx_itop_id}') {\r\n            throw 'Incorrect iTop ticket ID given: ' + Itop.params.id;\r\n        }\r\n        Itop.setUpdatePayload();\r\n        Itop.request(json_data);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ iTop Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_itop_link}", "event_menu_name": "iTop: {EVENT.TAGS.__zbx_itop_key}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "itop_api_version", "value": "1.3"}, {"name": "itop_class", "value": "UserRequest"}, {"name": "itop_comment", "value": "Created by Zabbix action {ACTION.NAME}"}, {"name": "itop_id", "value": "{EVENT.TAGS.__zbx_itop_id}"}, {"name": "itop_log", "value": "private_log"}, {"name": "itop_organization_id", "value": "<PLACE ORGANIZATION ID>"}, {"name": "itop_password", "value": "<PLACE PASSWORD OR TOKEN>"}, {"name": "itop_url", "value": "<PLACE YOUR ITOP URL>"}, {"name": "itop_user", "value": "<PLACE LOGIN>"}]}, {"mediatypeid": "27", "type": "4", "name": "Rocket.Chat", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var RocketChat = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        RocketChat.params = params;\r\n        if (RocketChat.params.url && RocketChat.params.api_url) {\r\n            if (!RocketChat.params.url.endsWith('/')) {\r\n                RocketChat.params.url += '/';\r\n            }\r\n            if (!RocketChat.params.api_url.endsWith('/')) {\r\n                RocketChat.params.api_url += '/';\r\n            }\r\n            if (RocketChat.params.api_url.startsWith('/')) {\r\n                RocketChat.params.api_url = RocketChat.params.api_url.substring(1);\r\n            }\r\n\r\n            RocketChat.params.url += RocketChat.params.api_url;\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        RocketChat.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    addFields: function (fields) {\r\n        var data = [];\r\n\r\n        if (typeof fields === 'object' && Object.keys(fields).length) {\r\n            Object.keys(fields)\r\n                .forEach(function(field) {\r\n                    if (fields[field] === '') {\r\n                        Zabbix.log(4, '[ RocketChat Webhook ] Field \"' + field +\r\n                            '\" can\\'t be empty. The field ignored.');\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var parts = field.split(':'),\r\n                                prefix = parts[0].split('_');\r\n\r\n                            if (typeof prefix[2] === 'undefined'\r\n                                    || (prefix[2] === 'p' && params.event_value === '1')\r\n                                    || (prefix[2] === 'r' && params.event_value === '0')) {\r\n                                data.push({\r\n                                    title: field.substring(field.indexOf(':') + 1),\r\n                                    value: fields[field],\r\n                                    short: prefix[1] === 'short'\r\n                                });\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            Zabbix.log(4, '[ RocketChat Webhook ] Can\\'t parse field \"' + field +\r\n                                '\". The field ignored.');\r\n                        }\r\n                    }\r\n                });\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        ['url', 'api_url', 'user_id', 'user_token', 'send_to'].forEach(function (field) {\r\n            if (typeof RocketChat.params !== 'object' || typeof RocketChat.params[field] === 'undefined'\r\n                    || RocketChat.params[field] === '' ) {\r\n                throw 'Required parameter is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            url = RocketChat.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('X-Auth-Token:' + RocketChat.params.user_token);\r\n        request.addHeader('X-User-Id:' + RocketChat.params.user_id);\r\n\r\n        if (typeof RocketChat.HTTPProxy !== 'undefined' && RocketChat.HTTPProxy !== '') {\r\n            request.setProxy(RocketChat.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ RocketChat Webhook ] Sending request: ' + url +\r\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        switch (method) {\r\n            case 'get':\r\n                response = request.get(url, data);\r\n                break;\r\n\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ RocketChat Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ RocketChat Webhook ] Failed to parse response received from RocketChat');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.message !== 'undefined') {\r\n                message += ': ' + JSON.stringify(response.message);\r\n            }\r\n            else if (response !== null && typeof response.error !== 'undefined') {\r\n                message += ': ' + JSON.stringify(response.error);\r\n            }\r\n\r\n            throw message + '. Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            status: request.getStatus(),\r\n            response: response\r\n        };\r\n    },\r\n\r\n    postMessage: function(use_default_message, message, fields) {\r\n        var data = {\r\n            channel: RocketChat.params.send_to,\r\n            attachments: [{\r\n                collapsed: false,\r\n                color: RocketChat.params.color,\r\n                title: params.alert_subject\r\n            }]\r\n        };\r\n\r\n        if (RocketChat.params.title_link) {\r\n            data.attachments[0].title_link = RocketChat.params.title_link;\r\n        }\r\n\r\n        if (use_default_message) {\r\n            data.attachments[0].text = message;\r\n        }\r\n        else {\r\n            data.attachments[0].fields = RocketChat.addFields(fields);\r\n        }\r\n\r\n        var result = RocketChat.request('post', 'chat.postMessage', data);\r\n\r\n        if (typeof result.response !== 'object' || typeof result.response.message._id === 'undefined') {\r\n            throw 'Cannot send RocketChat message. Check debug log for more information.';\r\n        }\r\n\r\n        return {\r\n            id: result.response.message._id,\r\n            rid: result.response.message.rid,\r\n            channel: result.response.channel\r\n        };\r\n    },\r\n\r\n    sendMessage: function(update, fields) {\r\n\r\n        var data = {\r\n            message: {\r\n                rid: RocketChat.params.room_id,\r\n                tmid: RocketChat.params.msg_id,\r\n                tshow: true\r\n            }\r\n        };\r\n\r\n        if (update.status === '0') {\r\n            data.message.attachments = [{\r\n                collapsed: false,\r\n                color: RocketChat.params.color,\r\n                title: params.alert_subject,\r\n                title_link: RocketChat.params.title_link,\r\n                fields: RocketChat.addFields(fields)\r\n            }];\r\n        }\r\n        else {\r\n            data.message.alias = update.user;\r\n            data.message.msg = update.action;\r\n            if (update.message) {\r\n                data.message.attachments = [{\r\n                    color: RocketChat.params.color,\r\n                    text: update.message\r\n                }];\r\n            }\r\n        }\r\n\r\n        RocketChat.request('post', 'chat.sendMessage', data);\r\n    },\r\n\r\n    getMessageLink: function(rid, id) {\r\n        var room = RocketChat.request('get', 'rooms.info?roomId=' + encodeURIComponent(rid)),\r\n            link = params.rc_url +\r\n                (params.rc_url.endsWith('/') ? '' : '/');\r\n\r\n        switch (room.response.room.t) {\r\n            case 'c':\r\n                link += 'channel/' + room.response.room.name + '?msg=' + id;\r\n                break;\r\n\r\n            case 'p':\r\n                link += 'group/' + room.response.room.name + '?msg=' + id;\r\n                break;\r\n\r\n            case 'd':\r\n                link += 'direct/' + rid + '?msg=' + id;\r\n                break;\r\n\r\n            default:\r\n                Zabbix.log(4, '[ RocketChat Webhook ] Can\\'t get room type. Link to message will not be added.');\r\n        }\r\n\r\n        return link;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        response,\r\n        fields = {},\r\n        rc = {},\r\n        update = {},\r\n        result = {tags: {}},\r\n        required_params = ['alert_subject', 'alert_message', 'event_source', 'event_value'],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: 'default', color: '#000000'}\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('rc_')) {\r\n                rc[key.substring(3)] = params[key];\r\n            }\r\n            else if (key.startsWith('field_')) {\r\n                fields[key.substring(6)] = params[key];\r\n            }\r\n            else if (key.startsWith('event_update_')) {\r\n                update[key.substring(13)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Forcing parameters for non trigger-based events.\r\n    if (params.event_source !== '0') {\r\n        params.use_default_message = 'true';\r\n        params.event_nseverity = '0';\r\n        params.rc_title_link = false;\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n            && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    RocketChat.setParams(rc);\r\n    RocketChat.setProxy(params.HTTPProxy);\r\n    RocketChat.params.color = severities[params.event_nseverity].color;\r\n\r\n    // Send default message if use_default_message === true.\r\n    if (params.use_default_message.toLowerCase() === 'true') {\r\n        response = RocketChat.postMessage(true, params.alert_message);\r\n        result.tags.__zbx_rc_id = response.id;\r\n        result.tags.__zbx_rc_rid = response.rid;\r\n        result.tags.__zbx_rc_msg_url = RocketChat.getMessageLink(response.rid, response.id);\r\n    }\r\n    // Send message for trigger-based events.\r\n    else if (params.event_value === '1' && update.status === '0') {\r\n        response = RocketChat.postMessage(false, params.alert_message, fields);\r\n        result.tags.__zbx_rc_id = response.id;\r\n        result.tags.__zbx_rc_rid = response.rid;\r\n        result.tags.__zbx_rc_msg_url = RocketChat.getMessageLink(response.rid, response.id);\r\n    }\r\n    // Send thread message for trigger-based event.\r\n    else {\r\n        RocketChat.sendMessage(update, fields);\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ RocketChat Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_rc_msg_url}", "event_menu_name": "Rocket.Chat", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_action", "value": "{EVENT.UPDATE.ACTION}"}, {"name": "event_update_message", "value": "{EVENT.UPDATE.MESSAGE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_update_user", "value": "{USER.FULLNAME}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "field_1_full:Host", "value": "{HOST.NAME} [{HOST.IP}]"}, {"name": "field_2_short:Severity", "value": "{EVENT.SEVERITY}"}, {"name": "field_3_short:Event time", "value": "{EVENT.DATE} {EVENT.TIME}"}, {"name": "field_3_short_r:Recovery time", "value": "{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}"}, {"name": "field_4_short_r:Event duration", "value": "{EVENT.DURATION}"}, {"name": "field_5_short:Operational data", "value": "{EVENT.OPDATA}"}, {"name": "field_999_full_p:Trigger description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "rc_api_url", "value": "api/v1/"}, {"name": "rc_msg_id", "value": "{EVENT.TAGS.__zbx_rc_id}"}, {"name": "rc_room_id", "value": "{EVENT.TAGS.__zbx_rc_rid}"}, {"name": "rc_send_to", "value": "{ALERT.SENDTO}"}, {"name": "rc_title_link", "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"}, {"name": "rc_url", "value": "<PLACE YOUR INSTANCE URL HERE>"}, {"name": "rc_user_id", "value": "<PLACE USER ID HERE>"}, {"name": "rc_user_token", "value": "<PLACE TOKEN HERE>"}, {"name": "use_default_message", "value": "false"}]}, {"mediatypeid": "28", "type": "4", "name": "VictorOps", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var VictorOps = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        VictorOps.params = params;\r\n        if (VictorOps.params.endpoint) {\r\n            if (!VictorOps.params.endpoint.endsWith('/')) {\r\n                VictorOps.params.endpoint += '/';\r\n            }\r\n\r\n            if (typeof VictorOps.params.routing_key !== 'undefined'\r\n                    && VictorOps.params.routing_key !== '{ALERT.SENDTO}'\r\n                    && VictorOps.params.routing_key !== 'Default') {\r\n                VictorOps.params.endpoint += VictorOps.params.routing_key;\r\n            }\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        VictorOps.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    addFields: function (fields) {\r\n        var data = {};\r\n\r\n        if (typeof fields === 'object') {\r\n            Object.keys(fields)\r\n                .forEach(function(field) {\r\n                    if (fields[field] === '') {\r\n                        Zabbix.log(4, '[ VictorOps Webhook ] Field \"' + field +\r\n                            '\" can\\'t be empty. The field ignored.');\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var parts = field.split(':'),\r\n                                prefix = parts[0].split('_');\r\n\r\n                            if (typeof prefix[1] === 'undefined'\r\n                                    || (prefix[1] === 'p' && params.event_value === '1'\r\n                                        && (params.event_update_status === '0'\r\n                                            || params.event_update_status === '{EVENT.UPDATE.STATUS}'))\r\n                                    || (prefix[1] === 'r' && params.event_value === '0'\r\n                                        && (params.event_update_status === '0'\r\n                                            || params.event_update_status === '{EVENT.UPDATE.STATUS}'))\r\n                                    || (prefix[1] === 'u' && params.event_update_status === '1')) {\r\n                                data[field.substring(field.indexOf(':') + 1)] = fields[field];\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            Zabbix.log(4, '[ VictorOps Webhook ] Can\\'t parse field \"' + field +\r\n                                '\". The field ignored.');\r\n                        }\r\n                    }\r\n                });\r\n        }\r\n\r\n        return data;\r\n    },\r\n\r\n    request: function (data) {\r\n        if (typeof VictorOps.params !== 'object' || typeof VictorOps.params.endpoint === 'undefined'\r\n                || VictorOps.params.endpoint === '' ) {\r\n            throw 'Required parameter is not set: \"vops_endpoint\".';\r\n        }\r\n\r\n        var response,\r\n            url = VictorOps.params.endpoint,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n\r\n        if (typeof VictorOps.HTTPProxy !== 'undefined' && VictorOps.HTTPProxy !== '') {\r\n            request.setProxy(VictorOps.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ VictorOps Webhook ] Sending request: ' + url +\r\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        response = request.post(url, data);\r\n\r\n        Zabbix.log(4, '[ VictorOps Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ VictorOps Webhook ] Failed to parse response received from VictorOps');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response !== null && typeof response.messages !== 'undefined') {\r\n                message += ': ' + JSON.stringify(response.messages);\r\n            }\r\n\r\n            throw message + '. Check debug log for more information.';\r\n        }\r\n\r\n        return response;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        vops = {},\r\n        required_params = ['event_source', 'event_value', 'priority_update'],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'resolved', color: '#009900'},\r\n            {name: 'default', color: '#000000'}\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('vops_')) {\r\n                vops[key.substring(5)] = params[key];\r\n            }\r\n            else if (key.startsWith('field')) {\r\n                fields[key.substring(5)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n            && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '7';\r\n    }\r\n\r\n    if (params.event_value === '0') {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    if (params.event_update_status === '1') {\r\n        fields[':message_type'] = params.priority_update;\r\n    }\r\n    else {\r\n        fields[':message_type'] = params['priority_' + severities[params.event_nseverity].name]\r\n            || 'INFO';\r\n    }\r\n\r\n    if (params.event_info && params.event_source === '0') {\r\n        fields[':event_info'] = params.event_info;\r\n    }\r\n\r\n    VictorOps.setParams(vops);\r\n    VictorOps.setProxy(params.HTTPProxy);\r\n    VictorOps.request(VictorOps.addFields(fields));\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ VictorOps Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "event_info", "value": "{$ZABBIX.URL}/tr_events.php?triggerid={TRIGGER.ID}&eventid={EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "field:entity_display_name", "value": "{ALERT.SUBJECT}"}, {"name": "field:entity_id", "value": "{EVENT.ID}"}, {"name": "field:hostname", "value": "{HOST.NAME}"}, {"name": "field:monitoring_tool", "value": "Zabbix"}, {"name": "field:operational_data", "value": "{EVENT.OPDATA}"}, {"name": "field:severity", "value": "{EVENT.SEVERITY}"}, {"name": "field:state_message", "value": "{ALERT.MESSAGE}"}, {"name": "field_p:trigger_description", "value": "{TRIGGER.DESCRIPTION}"}, {"name": "field_r:event_duration", "value": "{EVENT.DURATION}"}, {"name": "field_r:recovery time", "value": "{EVENT.RECOVERY.DATE} {EVENT.RECOVERY.TIME}"}, {"name": "priority_average", "value": "WARNING"}, {"name": "priority_default", "value": "INFO"}, {"name": "priority_disaster", "value": "CRITICAL"}, {"name": "priority_high", "value": "WARNING"}, {"name": "priority_information", "value": "INFO"}, {"name": "priority_not_classified", "value": "INFO"}, {"name": "priority_resolved", "value": "OK"}, {"name": "priority_update", "value": "INFO"}, {"name": "priority_warning", "value": "INFO"}, {"name": "vops_endpoint", "value": "<PLACE ENDPOINT URL HERE>"}, {"name": "vops_routing_key", "value": "{ALERT.SENDTO}"}]}, {"mediatypeid": "29", "type": "4", "name": "Brevis.one", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var BrevisOne = {\r\n    params: [],\r\n\r\n    addParam: function (name, value) {\r\n        BrevisOne.params.push(name + '=' + encodeURIComponent(value));\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        BrevisOne.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    setPayload: function (params) {\r\n        var parts = params.send_to.split(':'),\r\n            defaultValues = {\r\n                ring: 'true',\r\n                flash: 'true',\r\n                telauto: 'false'\r\n            };\r\n\r\n        BrevisOne.addParam('username', params.username);\r\n        BrevisOne.addParam('password', params.password);\r\n        BrevisOne.addParam('text', params.text);\r\n\r\n        if (parts.length > 1) {\r\n            BrevisOne.addParam('mode', parts[0]);\r\n            BrevisOne.addParam('to', parts[1]);\r\n        }\r\n        else {\r\n            BrevisOne.addParam('to', parts[0]);\r\n        }\r\n\r\n        Object.keys(defaultValues)\r\n            .forEach(function (key) {\r\n                if (params[key] && params[key].trim() && params[key].toLowerCase() === defaultValues[key]) {\r\n                    BrevisOne.addParam(key, defaultValues[key]);\r\n                }\r\n            });\r\n    },\r\n\r\n    request: function () {\r\n        var response,\r\n            request = new HttpRequest(),\r\n            data = '?' + BrevisOne.params.join('&');\r\n\r\n        request.addHeader('Content-Type: multipart/form-data');\r\n\r\n        if (typeof BrevisOne.HTTPProxy !== 'undefined' && BrevisOne.HTTPProxy !== '') {\r\n            request.setProxy(BrevisOne.HTTPProxy);\r\n        }\r\n\r\n        Zabbix.log(4, '[ BrevisOne Webhook ] Sending request.');\r\n\r\n        response = request.post(params.endpoint + data);\r\n\r\n        Zabbix.log(4, '[ BrevisOne Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response) {\r\n                message += ': ' + response;\r\n            }\r\n\r\n            throw message + '. Check debug log for more information.';\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value);\r\n\r\n    ['endpoint', 'password', 'username', 'text', 'send_to'].forEach(function (field) {\r\n        if (typeof params !== 'object' || typeof params[field] === 'undefined'\r\n                || !params[field].trim()) {\r\n            throw 'Required parameter is not set: \"' + field + '\".';\r\n        }\r\n    });\r\n\r\n    if (params.send_to === '{ALERT.SENDTO}') {\r\n        throw 'Required parameter is not set: \"send_to\".';\r\n    }\r\n\r\n    BrevisOne.setProxy(params.HTTPProxy);\r\n    BrevisOne.setPayload(params);\r\n    BrevisOne.request();\r\n\r\n    return 'OK';\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ BrevisOne Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "endpoint", "value": "<PLACE HTTP API URL>"}, {"name": "flash", "value": "false"}, {"name": "password", "value": "<PLACE PASSWORD>"}, {"name": "ring", "value": "false"}, {"name": "send_to", "value": "{ALERT.SENDTO}"}, {"name": "telauto", "value": "true"}, {"name": "text", "value": "{ALERT.MESSAGE}"}, {"name": "username", "value": "<PLACE USERNAME>"}]}, {"mediatypeid": "30", "type": "4", "name": "Express.ms", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Express = {\r\n    params: [],\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        Express.params = params;\r\n\r\n        if (typeof Express.params.url === 'string' && !Express.params.url.endsWith('/')) {\r\n            Express.params.url += '/';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Express.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    request: function (query, data) {\r\n        var response,\r\n            url = Express.params.url + query,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: Bearer ' + Express.params.token);\r\n\r\n        if (typeof Express.HTTPProxy !== 'undefined' && Express.HTTPProxy !== '') {\r\n            request.setProxy(Express.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Express Webhook ] Sending request: ' + url +\r\n            ((typeof data === 'string') ? ('\\n' + data) : ''));\r\n\r\n        response = request.post(url, data);\r\n\r\n        Zabbix.log(4, '[ Express Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Express Webhook ] Failed to parse response received from Express');\r\n                response = {};\r\n            }\r\n        }\r\n\r\n        if (response.status !== 'ok') {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (typeof response.reason !== 'undefined') {\r\n                message += ': ' + JSON.stringify(response.reason);\r\n            }\r\n\r\n            throw message + '. Check debug log for more information.';\r\n        }\r\n\r\n        return response.result;\r\n    },\r\n\r\n    postMessage: function (is_problem) {\r\n        var data,\r\n            url,\r\n            result = {tags: {}},\r\n            response;\r\n\r\n        if (is_problem) {\r\n            data = {\r\n                group_chat_id: Express.params.send_to,\r\n                notification: {\r\n                    status: 'ok',\r\n                    body: Express.params.message\r\n                }\r\n            };\r\n            url = 'api/v4/botx/notifications/direct';\r\n        }\r\n        else {\r\n            data = {\r\n                reply: {\r\n                    status: 'ok',\r\n                    body: Express.params.message\r\n                }\r\n            };\r\n            url = 'api/v3/botx/events/reply_event';\r\n\r\n            try {\r\n                var tags = JSON.parse(Express.params.tags);\r\n            }\r\n            catch (error) {\r\n                throw 'Value of \"express_tags\" is not JSON. Value: ' + Express.params.tags + '.';\r\n            }\r\n\r\n            tags.forEach(function(tag) {\r\n                if (tag.tag === '__zbx_ex_sync_id_' + Express.params.send_to) {\r\n                    data.source_sync_id = tag.value;\r\n                }\r\n            });\r\n\r\n            if (!data.source_sync_id) {\r\n                throw 'Cannot update data. sync_id for the provided sender is unknown.';\r\n            }\r\n        }\r\n\r\n        response = Express.request(url, data);\r\n\r\n        if (is_problem && response.sync_id) {\r\n            result.tags['__zbx_ex_sync_id_' + Express.params.send_to] = response.sync_id;\r\n\r\n            return JSON.stringify(result);\r\n        }\r\n        else {\r\n            return 'OK';\r\n        }\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        express = {},\r\n        required_params = [\r\n            'express_url', 'express_send_to', 'express_message', 'express_tags', 'express_token',\r\n            'event_source', 'event_value', 'event_update_status'\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('express_')) {\r\n                express[key.substring(8)] = params[key];\r\n            }\r\n\r\n            if (required_params.indexOf(key) !== -1\r\n                    && (params[key].trim() === '' || params[key] === '{ALERT.SENDTO}')) {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Forcing event_value and event_update_status for non trigger-based events.\r\n    if (params.event_source !== '0' ) {\r\n        params.event_value = '1';\r\n        params.event_update_status = '0';\r\n    }\r\n\r\n    if (params.event_value !== '0' && params.event_value !== '1') {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    Express.setParams(express);\r\n    Express.setProxy(params.HTTPProxy);\r\n\r\n    return Express.postMessage(params.event_value === '1' && params.event_update_status === '0');\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ Express Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": [{"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "express_message", "value": "{ALERT.MESSAGE}"}, {"name": "express_send_to", "value": "{ALERT.SENDTO}"}, {"name": "express_tags", "value": "{EVENT.TAGSJSON}"}, {"name": "express_token", "value": "<PLACE BOT TOKEN>"}, {"name": "express_url", "value": "<PLACE INSTANCE URL>"}]}, {"mediatypeid": "31", "type": "4", "name": "ManageEngine ServiceDesk", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var MEngine = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n\r\n        MEngine.params = params;\r\n        if (typeof MEngine.params.url === 'string') {\r\n            if (!MEngine.params.url.endsWith('/')) {\r\n                MEngine.params.url += '/';\r\n            }\r\n\r\n            MEngine.params.url += 'api/v3/';\r\n        }\r\n\r\n        if (MEngine.params.on_premise.toLowerCase() !== 'true'\r\n                && typeof MEngine.params.on_demand_url_auth === 'string') {\r\n            if (!MEngine.params.on_demand_url_auth.endsWith('/')) {\r\n                MEngine.params.on_demand_url_auth += '/';\r\n            }\r\n\r\n            MEngine.params.on_demand_url_auth += 'oauth/v2/token?';\r\n        }\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        MEngine.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    createLink: function (id, url) {\r\n        return url + (url.endsWith('/') ? '' : '/') +\r\n            ((MEngine.params.on_premise.toLowerCase() === 'true')\r\n                ? ('WorkOrder.do?woMode=viewWO&woID=' + id)\r\n                : ('app/itdesk/ui/requests/' + id + '/details')\r\n            );\r\n    },\r\n\r\n    refreshAccessToken: function () {\r\n        [\r\n            'on_demand_url_auth',\r\n            'on_demand_refresh_token',\r\n            'on_demand_client_id',\r\n            'on_demand_client_secret'\r\n        ].forEach(function (field) {\r\n            if (typeof MEngine.params !== 'object' || typeof MEngine.params[field] === 'undefined'\r\n                    || MEngine.params[field].trim() === '' ) {\r\n                throw 'Required MEngine param is not set: \"sd_' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            request = new HttpRequest(),\r\n            url = MEngine.params.on_demand_url_auth +\r\n                'refresh_token=' + encodeURIComponent(MEngine.params.on_demand_refresh_token) +\r\n                '&grant_type=refresh_token&client_id=' + encodeURIComponent(MEngine.params.on_demand_client_id) +\r\n                '&client_secret=' + encodeURIComponent(MEngine.params.on_demand_client_secret) +\r\n                '&redirect_uri=https://www.zoho.com&scope=SDPOnDemand.requests.ALL';\r\n\r\n        if (MEngine.HTTPProxy) {\r\n            request.setProxy(MEngine.HTTPProxy);\r\n        }\r\n\r\n        Zabbix.log(4, '[ ManageEngine Webhook ] Refreshing access token. Request: ' + url);\r\n\r\n        response = request.post(url);\r\n\r\n        Zabbix.log(4, '[ ManageEngine Webhook ] Received response with status code ' +\r\n        request.getStatus() + '\\n' + response);\r\n\r\n        try {\r\n            response = JSON.parse(response);\r\n        }\r\n        catch (error) {\r\n            Zabbix.log(4, '[ ManageEngine Webhook ] Failed to parse response received from Zoho Accounts');\r\n        }\r\n\r\n        if ((request.getStatus() < 200 || request.getStatus() >= 300) && !response.access_token) {\r\n            throw 'Access token refresh failed with HTTP status code ' + request.getStatus() +\r\n                '. Check debug log for more information.';\r\n        }\r\n        else {\r\n            MEngine.params.on_demand_auth_token = response.access_token;\r\n        }\r\n    },\r\n\r\n    request: function (method, query, data) {\r\n        var response,\r\n            url = MEngine.params.url + query,\r\n            input,\r\n            request = new HttpRequest(),\r\n            message;\r\n\r\n        if (MEngine.params.on_premise.toLowerCase() === 'true') {\r\n            request.addHeader('TECHNICIAN_KEY: ' + MEngine.params.on_premise_auth_token);\r\n        }\r\n        else {\r\n            request.addHeader('Authorization: Zoho-oauthtoken ' + MEngine.params.on_demand_auth_token);\r\n            request.addHeader('Accept: application/v3+json');\r\n        }\r\n\r\n        if (MEngine.HTTPProxy) {\r\n            request.setProxy(MEngine.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        input = 'input_data=' + encodeURIComponent(data);\r\n        Zabbix.log(4, '[ ManageEngine Webhook ] Sending request: ' + url + '?' + input);\r\n\r\n        switch (method) {\r\n            case 'post':\r\n                response = request.post(url, input);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, input);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ ManageEngine Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        try {\r\n            response = JSON.parse(response);\r\n        }\r\n        catch (error) {\r\n            Zabbix.log(4, '[ ManageEngine Webhook ] Failed to parse response received from ManageEngine');\r\n        }\r\n\r\n        if ((request.getStatus() < 200 || request.getStatus() >= 300)\r\n                && typeof response.response_status !== 'object') {\r\n            throw 'Request failed with HTTP status code ' + request.getStatus() +\r\n                '. Check debug log for more information.';\r\n        }\r\n        else if (typeof response.response_status === 'object' && response.response_status.status === 'failed') {\r\n            message = 'Request failed with status_code ';\r\n\r\n            if (typeof response.response_status.messages === 'object'\r\n                    && response.response_status.messages[0]\r\n                    && response.response_status.messages[0].message) {\r\n                message += response.response_status.messages[0].status_code +\r\n                    '. Message: ' + response.response_status.messages[0].message;\r\n            }\r\n            else {\r\n                message += response.response_status.status_code;\r\n            }\r\n\r\n            message += '. Check debug log for more information.';\r\n            throw message;\r\n        }\r\n        else if (response.request) {\r\n            return response.request.id;\r\n        }\r\n    },\r\n\r\n    createPaylaod: function (fields, isNote) {\r\n        var data = {},\r\n            result;\r\n\r\n        if (isNote) {\r\n            data.description = fields['field_string:description'].replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\r\n            result = {request_note: data};\r\n        }\r\n        else {\r\n            Object.keys(fields)\r\n                .forEach(function(field) {\r\n                    if (fields[field].trim() === '') {\r\n                        Zabbix.log(4, '[ ManageEngine Webhook ] Field \"' + field +\r\n                            '\" can\\'t be empty. The field ignored.');\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var prefix = field.split(':')[0],\r\n                                root;\r\n\r\n                            if  (prefix.startsWith('udf_') && !data.udf_fields) {\r\n                                data.udf_fields = {};\r\n                                root = data.udf_fields;\r\n                            }\r\n                            else if (prefix.startsWith('udf_')) {\r\n                                root = data.udf_fields;\r\n                            }\r\n                            else {\r\n                                root = data;\r\n                            }\r\n\r\n                            if (prefix.endsWith('string')) {\r\n                                root[field.substring(field.indexOf(':') + 1)\r\n                                    .toLowerCase()] = fields[field];\r\n                            }\r\n                            else {\r\n                                root[field.substring(field.indexOf(':') + 1)\r\n                                    .toLowerCase()] = {\r\n                                    name: fields[field]\r\n                                };\r\n                            }\r\n                        }\r\n                        catch (error) {\r\n                            Zabbix.log(4, '[ ManageEngine Webhook ] Can\\'t parse field \"' + field +\r\n                                '\". The field ignored.');\r\n                        }\r\n                    }\r\n                });\r\n            if (data.description) {\r\n                data.description = data.description.replace(/(?:\\r\\n|\\r|\\n)/g, '<br>');\r\n            }\r\n\r\n            result = {request: data};\r\n        }\r\n\r\n        return result;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        fields = {},\r\n        sd = {},\r\n        result = {tags: {}},\r\n        required_params = [\r\n            'sd_on_premise', 'field_string:subject', 'field_string:description',\r\n            'event_recovery_value', 'event_source', 'event_value', 'event_update_status'\r\n        ],\r\n        severities = [\r\n            {name: 'not_classified', color: '#97AAB3'},\r\n            {name: 'information', color: '#7499FF'},\r\n            {name: 'warning', color: '#FFC859'},\r\n            {name: 'average', color: '#FFA059'},\r\n            {name: 'high', color: '#E97659'},\r\n            {name: 'disaster', color: '#E45959'},\r\n            {name: 'default', color: '#000000'}\r\n        ];\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('sd_')) {\r\n                sd[key.substring(3)] = params[key];\r\n            }\r\n            else if (key.startsWith('field_') || key.startsWith('udf_field_')) {\r\n                fields[key] = params[key];\r\n            }\r\n\r\n            if (required_params.indexOf(key) !== -1 && params[key].trim() === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if ([0, 1, 2, 3, 4, 5].indexOf(parseInt(params.event_nseverity)) === -1) {\r\n        params.event_nseverity = '6';\r\n    }\r\n\r\n    if (params.event_update_status === '1' && (typeof params.sd_request_id === 'undefined'\r\n            || params.sd_request_id.trim() === ''\r\n            || params.sd_request_id === '{EVENT.TAGS.__zbx_sd_request_id}')) {\r\n        throw 'Parameter \"sd_request_id\" can\\'t be empty for update operation.';\r\n    }\r\n\r\n    MEngine.setParams(sd);\r\n    MEngine.setProxy(params.HTTPProxy);\r\n\r\n    if (MEngine.params.on_premise.toLowerCase() !== 'true') {\r\n        MEngine.refreshAccessToken();\r\n    }\r\n\r\n    // Create issue for non trigger-based events.\r\n    if (params.event_source !== '0' && params.event_recovery_value !== '0') {\r\n        fields['field_object:priority'] = params['priority_' + severities[params.event_nseverity].name]\r\n        || 'Normal';\r\n\r\n        MEngine.request('post', 'requests', MEngine.createPaylaod(fields));\r\n    }\r\n    // Create issue for trigger-based events.\r\n    else if (params.event_value === '1' && params.event_update_status === '0') {\r\n        fields['field_object:priority'] = params['priority_' + severities[params.event_nseverity].name]\r\n        || 'Normal';\r\n\r\n        var id = MEngine.request('post', 'requests', MEngine.createPaylaod(fields));\r\n\r\n        result.tags.__zbx_sd_request_id = id;\r\n        result.tags.__zbx_sd_request_link = MEngine.createLink(id, params.sd_url);\r\n    }\r\n    // Update created issue for trigger-based event.\r\n    else {\r\n        if (params.event_update_status === '1') {\r\n            MEngine.request('post', 'requests/' + params.sd_request_id + '/notes',\r\n                MEngine.createPaylaod(fields, true)\r\n            );\r\n        }\r\n        delete fields['field_string:description'];\r\n        MEngine.request('put', 'requests/' + params.sd_request_id, MEngine.createPaylaod(fields));\r\n    }\r\n\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(3, '[ ManageEngine Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_sd_request_link}", "event_menu_name": "ManageEngine: {EVENT.TAGS.__zbx_sd_request_id}", "description": "", "parameters": [{"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "field_ref:requester", "value": "<PLACE API USER NAME>"}, {"name": "field_string:description", "value": "{ALERT.MESSAGE}"}, {"name": "field_string:subject", "value": "{ALERT.SUBJECT}"}, {"name": "priority_average", "value": "Normal"}, {"name": "priority_default", "value": "Normal"}, {"name": "priority_disaster", "value": "High"}, {"name": "priority_high", "value": "High"}, {"name": "priority_information", "value": "Low"}, {"name": "priority_not_classified", "value": "Low"}, {"name": "priority_warning", "value": "Medium"}, {"name": "sd_on_demand_client_id", "value": "<PLACE ON DEMAND CLIENT ID>"}, {"name": "sd_on_demand_client_secret", "value": "<PLACE ON DEMAND CLIENT SECRET>"}, {"name": "sd_on_demand_refresh_token", "value": "<PLACE ON DEMAND REFRESH TOKEN>"}, {"name": "sd_on_demand_url_auth", "value": "<PLACE AUTHENTICATION URL FOR ON DEMAND>"}, {"name": "sd_on_premise", "value": "true"}, {"name": "sd_on_premise_auth_token", "value": "<PLACE ON PREMISE TECHNICIAN_KEY>"}, {"name": "sd_request_id", "value": "{EVENT.TAGS.__zbx_sd_request_id}"}, {"name": "sd_url", "value": "<PLACE INSTANCE URL>"}, {"name": "trigger_description", "value": "{TRIGGER.DESCRIPTION}"}]}, {"mediatypeid": "32", "type": "4", "name": "Github", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "1", "script": "var Github = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n        Github.params = params;\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        Github.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    urlCheckFormat: function (url) {\r\n\r\n        if (typeof url === 'string' && !url.endsWith('/')) {\r\n            url += '/';\r\n        }\r\n\r\n        if (url.indexOf('http://') === -1 && url.indexOf('https://') === -1) {\r\n            url = 'https://' + url;\r\n        }\r\n\r\n        return url;\r\n    },\r\n\r\n    createProblemURL: function (zabbix_url, triggerid, eventid, event_source) {\r\n        var problem_url = zabbix_url;\r\n\r\n        if (event_source === '0') {\r\n            problem_url += 'tr_events.php?triggerid=' + triggerid + '&eventid=' + eventid;\r\n        }\r\n\r\n        return problem_url;\r\n    },\r\n\r\n    request: function (method, url, data) {\r\n        ['token', 'user_agent'].forEach(function (field) {\r\n            if (typeof Github.params !== 'object' || typeof Github.params[field] === 'undefined' || Github.params[field] === '') {\r\n                throw 'Required Github param is not set: \"' + field + '\".';\r\n            }\r\n        });\r\n\r\n        var response,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('User-Agent: ' + Github.params.user_agent);\r\n        request.addHeader('Accept: application/vnd.github.v3+json');\r\n        request.addHeader('Authorization: token ' + Github.params.token);\r\n\r\n        if (typeof Github.HTTPProxy !== 'undefined' && Github.HTTPProxy !== '') {\r\n            request.setProxy(Github.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ Github Webhook ] Sending request: ' + url + ((typeof data === 'string')\r\n            ? ('\\n' + data)\r\n            : ''));\r\n\r\n        switch (method) {\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'patch':\r\n                response = request.patch(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ Github Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ Github Webhook ] Failed to parse response received from Github');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (typeof response !== 'object') {\r\n            throw 'Failed to process response received from Github. Check debug log for more information.';\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response.message) {\r\n                message += ': ' + response.message;\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return response;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        github = {},\r\n        url = '',\r\n        data = {},\r\n        comment_data,\r\n        result = { tags: {} },\r\n        required_params = [\r\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\r\n            'event_update_status', 'event_recovery_value', 'event_severity',\r\n            'event_id', 'trigger_id', 'zabbix_url',\r\n            'github_token', 'github_url', 'github_user_agent'\r\n        ],\r\n        method = 'post',\r\n        process_tags = true;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('github_')) {\r\n                github[key.substring(7)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '' || params.zabbix_url === '{$ZABBIX.URL}') {\r\n        throw 'Field \"zabbix_url\" cannot be empty.';\r\n    }\r\n\r\n    // Check for backslash in the end of url and schema.\r\n    github.url = Github.urlCheckFormat(github.url);\r\n    params.zabbix_url = Github.urlCheckFormat(params.zabbix_url);\r\n\r\n    // Default url for creating issue\r\n    url = github.url + 'repos/' + github.repo + '/issues';\r\n\r\n    data.title = params.alert_subject;\r\n    data.body = params.alert_message;\r\n    data.labels = [\r\n        { name: \"Zabbix\" }\r\n    ];\r\n\r\n    // Adding label corresponding to trigger severity in Zabbix.\r\n    if (params.event_severity !== 'undefined' && params.event_source === '0') {\r\n        data.labels.push({ name: params.event_severity });\r\n    }\r\n\r\n    // In case of update or resolve event.\r\n    if (params.event_source === '0' && (params.event_value === '0' || params.event_update_status === '1')) {\r\n        process_tags = false;\r\n        method = 'patch';\r\n        url = github.url + 'repos/' + github.repo + '/issues/' + github.issue_number;\r\n        comment_data = Object.assign({}, data);\r\n        delete data.body;\r\n    } else {\r\n        problem_url = Github.createProblemURL(params.zabbix_url, params.trigger_id, params.event_id, params.event_source);\r\n        data.body += '\\nEvent details in Zabbix: [' + problem_url + '](' + problem_url + ')';\r\n    }\r\n\r\n    Github.setParams(github);\r\n    Github.setProxy(params.HTTPProxy);\r\n\r\n    var response = Github.request(method, url, data);\r\n\r\n    // Leave a comment if comment_data present.\r\n    if (typeof comment_data === 'object') {\r\n        url = github.url + 'repos/' + github.repo + '/issues/' + github.issue_number + '/comments';\r\n        Github.request(\"post\", url, comment_data);\r\n    }\r\n\r\n    if (process_tags) {\r\n        result.tags.__zbx_github_issue_number = response.number;\r\n        result.tags.__zbx_github_repo = github.repo;\r\n        result.tags.__zbx_github_link = response.html_url;\r\n    }\r\n\r\n    Zabbix.log(4, '[ Github Webhook ] Result: ' + JSON.stringify(result));\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ Github Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_github_link}", "event_menu_name": "Github: Issue {EVENT.TAGS.__zbx_github_issue_number}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_severity", "value": "{EVENT.SEVERITY}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "github_issue_number", "value": "{EVENT.TAGS.__zbx_github_issue_number}"}, {"name": "github_repo", "value": "{ALERT.SENDTO}"}, {"name": "github_token", "value": "<PLACE GITHUB TOKEN>"}, {"name": "github_url", "value": "https://api.github.com"}, {"name": "github_user_agent", "value": "Zabbix/6.0"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "33", "type": "4", "name": "GLPi", "smtp_server": "", "smtp_helo": "", "smtp_email": "", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "1", "attempt_interval": "10s", "content_type": "1", "script": "var GLPi = {\r\n    params: {},\r\n\r\n    setParams: function (params) {\r\n        if (typeof params !== 'object') {\r\n            return;\r\n        }\r\n        GLPi.params = params;\r\n    },\r\n\r\n    setProxy: function (HTTPProxy) {\r\n        GLPi.HTTPProxy = HTTPProxy;\r\n    },\r\n\r\n    urlCheckFormat: function (url) {\r\n        if (typeof url === 'string' && !url.endsWith('/')) {\r\n            url += '/';\r\n        }\r\n\r\n        if (url.indexOf('http://') === -1 && url.indexOf('https://') === -1) {\r\n            url = 'https://' + url;\r\n        }\r\n\r\n        return url;\r\n    },\r\n\r\n    getAuthToken: function (url, token) {\r\n        var response,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Authorization: user_token ' + token);\r\n\r\n        response = request.get(url + \"apirest.php/initSession\");\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ GLPi Webhook ] Failed to receive authentication token from GLPi.');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (Array.isArray(response)) {\r\n            if (response[1]) {\r\n                throw 'Error received from GLPi: ' + response[1];\r\n            } else {\r\n                throw 'Failed to receive authentication token from GLPi.';\r\n            }\r\n        }\r\n\r\n        if (typeof response !== 'object' || !response.session_token) {\r\n            throw 'Failed to process response received from getting GLPi authentication token. Check debug log for more information.';\r\n        }\r\n\r\n        return response.session_token;\r\n    },\r\n\r\n    getProblemUrl: function (zabbix_url, triggerid, eventid, event_source) {\r\n        var problem_url = zabbix_url;\r\n\r\n        if (event_source === '0') {\r\n            problem_url += 'tr_events.php?triggerid=' + triggerid + '&eventid=' + eventid;\r\n        }\r\n\r\n        return problem_url;\r\n    },\r\n\r\n    request: function (method, url, data) {\r\n        if (typeof GLPi.params !== 'object' || typeof GLPi.params.authToken === 'undefined' || GLPi.params.authToken === '') {\r\n            throw 'Required GLPi param authToken is not set.';\r\n        }\r\n\r\n        var response,\r\n            request = new HttpRequest();\r\n\r\n        request.addHeader('Content-Type: application/json');\r\n        request.addHeader('Session-Token:' + GLPi.params.authToken);\r\n\r\n        if (typeof GLPi.HTTPProxy !== 'undefined' && GLPi.HTTPProxy !== '') {\r\n            request.setProxy(GLPi.HTTPProxy);\r\n        }\r\n\r\n        if (typeof data !== 'undefined') {\r\n            data = JSON.stringify(data);\r\n        }\r\n\r\n        Zabbix.log(4, '[ GLPi Webhook ] Sending request: ' + url + ((typeof data === 'string')\r\n            ? ('\\n' + data)\r\n            : ''));\r\n\r\n        switch (method) {\r\n            case 'post':\r\n                response = request.post(url, data);\r\n                break;\r\n\r\n            case 'put':\r\n                response = request.put(url, data);\r\n                break;\r\n\r\n            default:\r\n                throw 'Unsupported HTTP request method: ' + method;\r\n        }\r\n\r\n        Zabbix.log(4, '[ GLPi Webhook ] Received response with status code ' +\r\n            request.getStatus() + '\\n' + response);\r\n\r\n        if (response !== null) {\r\n            try {\r\n                response = JSON.parse(response);\r\n            }\r\n            catch (error) {\r\n                Zabbix.log(4, '[ GLPi Webhook ] Failed to parse response received from GLPi');\r\n                response = null;\r\n            }\r\n        }\r\n\r\n        if (typeof response !== 'object' || typeof response === 'undefined' || response === null) {\r\n            throw 'Failed to process response received from GLPi. Check debug log for more information.';\r\n        }\r\n\r\n        if (request.getStatus() < 200 || request.getStatus() >= 300) {\r\n            var message = 'Request failed with status code ' + request.getStatus();\r\n\r\n            if (response.message) {\r\n                message += ': ' + response.message;\r\n            }\r\n\r\n            throw message + ' Check debug log for more information.';\r\n        }\r\n\r\n        return response;\r\n    }\r\n};\r\n\r\ntry {\r\n    var params = JSON.parse(value),\r\n        glpi = {},\r\n        url = '',\r\n        data = {},\r\n        comment_data,\r\n        result = { tags: {} },\r\n        required_params = [\r\n            'alert_subject', 'alert_message', 'event_source', 'event_value',\r\n            'event_update_status', 'event_recovery_value',\r\n            'event_id', 'trigger_id', 'zabbix_url',\r\n            'glpi_token', 'glpi_url'\r\n        ],\r\n        method = 'post',\r\n        process_tags = true,\r\n        response;\r\n\r\n    Object.keys(params)\r\n        .forEach(function (key) {\r\n            if (key.startsWith('glpi_')) {\r\n                glpi[key.substring(5)] = params[key];\r\n            }\r\n            else if (required_params.indexOf(key) !== -1 && params[key] === '') {\r\n                throw 'Parameter \"' + key + '\" can\\'t be empty.';\r\n            }\r\n        });\r\n\r\n    if ([0, 1, 2, 3].indexOf(parseInt(params.event_source)) === -1) {\r\n        throw 'Incorrect \"event_source\" parameter given: ' + params.event_source + '\\nMust be 0-3.';\r\n    }\r\n\r\n    // Check {EVENT.VALUE} for trigger-based and internal events.\r\n    if (params.event_value !== '0' && params.event_value !== '1'\r\n        && (params.event_source === '0' || params.event_source === '3')) {\r\n        throw 'Incorrect \"event_value\" parameter given: ' + params.event_value + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    // Check {EVENT.UPDATE.STATUS} only for trigger-based events.\r\n    if (params.event_update_status !== '0' && params.event_update_status !== '1' && params.event_source === '0') {\r\n        throw 'Incorrect \"event_update_status\" parameter given: ' + params.event_update_status + '\\nMust be 0 or 1.';\r\n    }\r\n\r\n    if (params.event_source !== '0' && params.event_recovery_value === '0') {\r\n        throw 'Recovery operations are supported only for trigger-based actions.';\r\n    }\r\n\r\n    if (typeof params.zabbix_url !== 'string' || params.zabbix_url.trim() === '' || params.zabbix_url === '{$ZABBIX.URL}') {\r\n        throw 'Field \"zabbix_url\" cannot be empty.';\r\n    }\r\n\r\n    // Check for backslash in the end of url and schema.\r\n    glpi.url = GLPi.urlCheckFormat(glpi.url);\r\n    params.zabbix_url = GLPi.urlCheckFormat(params.zabbix_url);\r\n\r\n    glpi.authToken = GLPi.getAuthToken(glpi.url, glpi.token);\r\n    GLPi.setParams(glpi);\r\n\r\n    data = {\r\n        'input': {\r\n            'name': params.alert_subject,\r\n            'content': params.alert_message + '\\n<a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '>Link to problem in Zabbix</a>',\r\n            'status': 1,  // Set status \"New\"\r\n            'urgency': params.event_nseverity\r\n        }\r\n    };\r\n\r\n    // In case of resolve\r\n    if (params.event_source === '0' && params.event_value === '0') {\r\n        process_tags = false;\r\n        dataFollowup = {\r\n            'input': {\r\n                'items_id': glpi.problem_id,\r\n                'itemtype': 'Problem',\r\n                'content': params.alert_message + '\\n<a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '>Link to problem in Zabbix</a>'\r\n            }\r\n        };\r\n        dataProblem = {\r\n            'id': glpi.problem_id,\r\n            'input': {\r\n                'name': params.alert_subject,\r\n                'status': 5,  // Set status \"Solved\"\r\n                'urgency': params.event_nseverity\r\n            }\r\n        };\r\n\r\n        GLPi.request('put', glpi.url + 'apirest.php/Problem/' + glpi.problem_id, dataProblem);\r\n        GLPi.request('post', glpi.url + 'apirest.php/Problem/' + glpi.problem_id + '/ITILFollowup', dataFollowup);\r\n    }\r\n\r\n    // In case of update\r\n    else if (params.event_source === '0' && params.event_update_status === '1') {\r\n        process_tags = false;\r\n        dataFollowup = {\r\n            'input': {\r\n                'items_id': glpi.problem_id,\r\n                'itemtype': 'Problem',\r\n                'content': params.alert_message + '\\n<a href=' + GLPi.getProblemUrl(params.zabbix_url, params.trigger_id, params.event_id, params.event_source) + '>Link to problem in Zabbix</a>'\r\n            }\r\n        };\r\n        dataProblem = {\r\n            'id': glpi.problem_id,\r\n            'input': {\r\n                'name': params.alert_subject,\r\n                'urgency': params.event_nseverity\r\n            }\r\n        };\r\n\r\n        GLPi.request('put', glpi.url + 'apirest.php/Problem/' + glpi.problem_id, dataProblem);\r\n        GLPi.request('post', glpi.url + 'apirest.php/Problem/' + glpi.problem_id + '/ITILFollowup', dataFollowup);\r\n    }\r\n\r\n    // In case of problem\r\n    else {\r\n        response = GLPi.request('post', glpi.url + 'apirest.php/Problem/', data);\r\n    }\r\n\r\n    if (process_tags) {\r\n        result.tags.__zbx_glpi_problem_id = response.id;\r\n        result.tags.__zbx_glpi_link = glpi.url + 'front/problem.form.php?id=' + response.id;\r\n    }\r\n\r\n    Zabbix.log(4, '[ GLPi Webhook ] Result: ' + JSON.stringify(result));\r\n    return JSON.stringify(result);\r\n}\r\ncatch (error) {\r\n    Zabbix.log(4, '[ GLPi Webhook ] ERROR: ' + error);\r\n    throw 'Sending failed: ' + error;\r\n}", "timeout": "30s", "process_tags": "1", "show_event_menu": "1", "event_menu_url": "{EVENT.TAGS.__zbx_glpi_link}", "event_menu_name": "GLPi: Problem {EVENT.TAGS.__zbx_glpi_problem_id}", "description": "", "parameters": [{"name": "alert_message", "value": "{ALERT.MESSAGE}"}, {"name": "alert_subject", "value": "{ALERT.SUBJECT}"}, {"name": "event_id", "value": "{EVENT.ID}"}, {"name": "event_nseverity", "value": "{EVENT.NSEVERITY}"}, {"name": "event_recovery_value", "value": "{EVENT.RECOVERY.VALUE}"}, {"name": "event_source", "value": "{EVENT.SOURCE}"}, {"name": "event_update_status", "value": "{EVENT.UPDATE.STATUS}"}, {"name": "event_value", "value": "{EVENT.VALUE}"}, {"name": "glpi_problem_id", "value": "{EVENT.TAGS.__zbx_glpi_problem_id}"}, {"name": "glpi_token", "value": "<PLACE GLPI TOKEN>"}, {"name": "glpi_url", "value": "<PLACE GLPI URL>"}, {"name": "trigger_id", "value": "{TRIGGER.ID}"}, {"name": "zabbix_url", "value": "{$ZABBIX.URL}"}]}, {"mediatypeid": "34", "type": "0", "name": ":.Email - Ancine", "smtp_server": "mail.ancine.gov.br", "smtp_helo": "correio.ancine.gov.br", "smtp_email": "srv_zabbix@ancine.gov.br", "exec_path": "", "gsm_modem": "", "username": "", "passwd": "", "status": "0", "smtp_port": "25", "smtp_security": "0", "smtp_verify_peer": "0", "smtp_verify_host": "0", "smtp_authentication": "0", "exec_params": "", "maxsessions": "1", "maxattempts": "3", "attempt_interval": "10s", "content_type": "0", "script": "", "timeout": "30s", "process_tags": "0", "show_event_menu": "0", "event_menu_url": "", "event_menu_name": "", "description": "", "parameters": []}]